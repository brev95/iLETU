(function() {
    SU.Cookie = function(name, value) {
        this.name    = name;
        this.value   = value;
        this.expires = null;
        this.path    = '/';

        // Use the TLD by default, this matches the PHP behavior
        this.domain = document.location.host.replace(/[^\.]*/, '');

        //not implemented
        this.secure = false;
    
        this.setExpirationSeconds = function(seconds) {
            var date = new Date();
            date.setTime(date.getTime() + (1000 * seconds));
            this.expires = date;
        };

        this.setExpirationHours = function(hours) {
            this.setExpirationSeconds(hours * 3600);
        };

        this.setExpirationDays = function(days) {
            this.setExpirationSeconds(days * 86400);
        };

        this.setDomain = function(domain) {
            this.domain = domain;
        };

        this.save = function() {
            var curCookie   = this.name + '=' + escape(this.value) +
                ((this.expires) ? '; expires=' + this.expires.toGMTString() : '') +
                ((this.path) ? '; path=' + this.path : '') +
                ((this.domain) ? '; domain=' + this.domain : '') +
                ((this.secure) ? '; secure' : '');
            document.cookie = curCookie;
        }

        this.read = function() {
            var nameEQ = this.name + "=";
            var ca     = document.cookie.split(';');
            for(var i = 0 ; i < ca.length ; i++) {
                var c = ca[i];
                while (c.charAt(0) == ' ') {
                    c = c.substring(1,c.length);
                }
                if (c.indexOf(nameEQ) == 0) {
                    this.value = unescape(c.substring(nameEQ.length,c.length));
                }
            }
            return this.value;
        };

        this.setValue = function(value) {
            this.value = value;
        };

        this.kill = function() {
            this.setExpirationSeconds(-86400);
            this.value = null;
            this.save();
        };
    };
}).call(this);var JSON;if(!JSON){JSON={};}
(function(){'use strict';function f(n){return n<10?'0'+n:n;}
if(typeof Date.prototype.toJSON!=='function'){Date.prototype.toJSON=function(key){return isFinite(this.valueOf())?this.getUTCFullYear()+'-'+
f(this.getUTCMonth()+1)+'-'+
f(this.getUTCDate())+'T'+
f(this.getUTCHours())+':'+
f(this.getUTCMinutes())+':'+
f(this.getUTCSeconds())+'Z':null;};String.prototype.toJSON=Number.prototype.toJSON=Boolean.prototype.toJSON=function(key){return this.valueOf();};}
var cx=/[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,escapable=/[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,gap,indent,meta={'\b':'\\b','\t':'\\t','\n':'\\n','\f':'\\f','\r':'\\r','"':'\\"','\\':'\\\\'},rep;function quote(string){escapable.lastIndex=0;return escapable.test(string)?'"'+string.replace(escapable,function(a){var c=meta[a];return typeof c==='string'?c:'\\u'+('0000'+a.charCodeAt(0).toString(16)).slice(-4);})+'"':'"'+string+'"';}
function str(key,holder){var i,k,v,length,mind=gap,partial,value=holder[key];if(value&&typeof value==='object'&&typeof value.toJSON==='function'){value=value.toJSON(key);}
if(typeof rep==='function'){value=rep.call(holder,key,value);}
switch(typeof value){case'string':return quote(value);case'number':return isFinite(value)?String(value):'null';case'boolean':case'null':return String(value);case'object':if(!value){return'null';}
gap+=indent;partial=[];if(Object.prototype.toString.apply(value)==='[object Array]'){length=value.length;for(i=0;i<length;i+=1){partial[i]=str(i,value)||'null';}
v=partial.length===0?'[]':gap?'[\n'+gap+partial.join(',\n'+gap)+'\n'+mind+']':'['+partial.join(',')+']';gap=mind;return v;}
if(rep&&typeof rep==='object'){length=rep.length;for(i=0;i<length;i+=1){if(typeof rep[i]==='string'){k=rep[i];v=str(k,value);if(v){partial.push(quote(k)+(gap?': ':':')+v);}}}}else{for(k in value){if(Object.prototype.hasOwnProperty.call(value,k)){v=str(k,value);if(v){partial.push(quote(k)+(gap?': ':':')+v);}}}}
v=partial.length===0?'{}':gap?'{\n'+gap+partial.join(',\n'+gap)+'\n'+mind+'}':'{'+partial.join(',')+'}';gap=mind;return v;}}
if(typeof JSON.stringify!=='function'){JSON.stringify=function(value,replacer,space){var i;gap='';indent='';if(typeof space==='number'){for(i=0;i<space;i+=1){indent+=' ';}}else if(typeof space==='string'){indent=space;}
rep=replacer;if(replacer&&typeof replacer!=='function'&&(typeof replacer!=='object'||typeof replacer.length!=='number')){throw new Error('JSON.stringify');}
return str('',{'':value});};}
if(typeof JSON.parse!=='function'){JSON.parse=function(text,reviver){var j;function walk(holder,key){var k,v,value=holder[key];if(value&&typeof value==='object'){for(k in value){if(Object.prototype.hasOwnProperty.call(value,k)){v=walk(value,k);if(v!==undefined){value[k]=v;}else{delete value[k];}}}}
return reviver.call(holder,key,value);}
text=String(text);cx.lastIndex=0;if(cx.test(text)){text=text.replace(cx,function(a){return'\\u'+
('0000'+a.charCodeAt(0).toString(16)).slice(-4);});}
if(/^[\],:{}\s]*$/.test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,'@').replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,']').replace(/(?:^|:|,)(?:\s*\[)+/g,''))){j=eval('('+text+')');return typeof reviver==='function'?walk({'':j},''):j;}
throw new SyntaxError('JSON.parse');};}}());/**
 * Request keychain. Holds auth for requests to API
 *   - tokens are for HTTP request security / anti-forgery
 *   - authString and OAuth are competing solutions to the same issue: user authentication
 */
var SU_ClientRequestKeychain = function() {
    this.tokens = {
        stumble: '',
        request: ''
    }

    this.authString = '';
    this.OAuth = {};
}

/**
 * SU Client API. Makes authenticated requests
 * stateless, except auth string and device/source ids (for convenience)
 */
var SU_Client = function(connectorClass) {
    //constructor logic here
    this.keychain = new SU_ClientRequestKeychain();
    this.connectorClass = connectorClass ? connectorClass : SU_ClientApiConnector;
    return true;
}
SU_Client.prototype = {
    AUTH_RETRY_WAIT: 15000,
    version: 1.0,
    device: '',
    source: '',
    clientVersion: '',
    scriptVersion: '',
    consumerKey: '',
    keychain: null,
    successFilter: null,
    errorFilter: null,

    /** api calls to server **/
    rate: function(publicid, rating, callback, noFacebookAutoshare, callbackError) {
        if (!callback) {
            callback = function(response) {
            }
        }
        this.makeRequest({action: 'simple-rate', pid: publicid, rating: rating, noFacebookAutoshare: noFacebookAutoshare}, callback, callbackError);
    },

    subrate: function(publicid, subrating, callback) {
        if (!callback) {
            callback = function(response) {
            }
        }
        this.makeRequest({action: 'simple-subrate', pid: publicid, subrating: subrating}, callback);
    },

    blocksite: function(publicid, blocksite, callback) {
        if (!callback) {
            callback = function(response) {
            }
        }
        this.makeRequest({action: 'blocksite', pid: publicid, blocksite: blocksite}, callback);
    },

    askAutoShareFacebook: function(callback) {
        if (!callback) return;
        this.makeRequest({action: 'askAutoShareFacebook'}, callback);
    },

    autoShareFacebook: function(publicid, url, callback) {
        if (!callback)  {
            callback = function(response) {
            }
        }
        this.makeRequest({action: 'autoShareFacebook', pid: publicid, url:url}, callback);
    },

    saveTimers: function(publicid, timers, callback) {
        if (!callback) {
            callback = function(response) {
            }
        }
        this.makeRequest({action: 'timers', pid: publicid, timers: timers}, callback);
    },

    getStumble: function(mode, callback) {
        var params = {};
        for (var i in mode)
        {
            if (i == 'extra')
            {
                for (var j in mode[i])
                    params[j] = mode[i][j];
            }
            else
            {
                params[i] = mode[i];
            }
        }
        params.action = 'stumble';

        return this.makeRequest(params, callback);
    },

    getStumbles: function(mode, callback) {
        var params = {};
        for (var i in mode)
        {
            if (i == 'extra')
            {
                for (var j in mode[i])
                    params[j] = mode[i][j];
            }
            else
            {
                params[i] = mode[i];
            }
        }
        params.action = 'getstumbles';

        return this.makeRequest(params, callback);
    },

    getShare: function(callback) {
        var params = {};
        params.action = 'referral';

        return this.makeRequest(params, callback);
    },

    getUserData: function(callback) {
        this.makeRequest({action: "userdata"}, callback);
    },

    getUrlInfo: function(url, callback) {
        this.makeRequest({
            action: 'geturlinfo',
            url: url
        }, callback);
    },

    getUserTopics: function() {
        this.makeRequest({action: "getTopics"}, callback);
    },

    checkForShares: function(callback) {
        this.makeRequest({action: "getFriendShares"}, callback);
    },

    getRequestToken: function(callback) {
        this.makeRequest({action: 'getState'}, callback);
    },

    getState: function(fnSuccess, fnFailure) {
        this.makeRequest({action: 'getState'}, fnSuccess, fnFailure);
    },

    getOAuthToken: function(callback) {
        this.makeRequest({action: 'getOAuthToken'}, callback);
    },

    endOAuthSession: function() {
        // Must supply a callback or it just returns a GET url
        this.makeRequest({action: 'endOAuthSession'}, function() { });
    },

    getAuthString: function(callback) {
        this.makeRequest({action: 'getAuth'}, callback);
    },

    logoutWebsite: function(callback) {
        this.makeRequest({action: 'logoutWebsite', logout: 1}, callback);
    },

    getStartSessionUrl: function(url) {
        // If you don't pass a callback to makeRequest it returns a GET-formatted URL
        return this.makeRequest({action: 'startSession', url:url });
    },

    trk: function(metric) {
        this.makeRequest({action:'rec', metric: metric}, function() {});
    },

    sendShare: function(shareInfo, callback) {
        this.makeRequest({
            action:'send',
            in_reply_to:shareInfo.referralId,
            msg: shareInfo.text,
            url: shareInfo.url
        }, callback);
    },

    sendEmailShare: function(shareInfo, callback) {
        throw "Not yet implemented";
    },

    markShareSeen: function(shareid){
        this.makeRequest({action:'markShareSeen', shareid: shareid}, function() {});
    },

    logEvent: function(event, count){
        if (!count) count = 1;
        this.makeRequest({action: 'logEvent', event: event, count: count}, function() {});
    },

    /** book-keeping functions **/
    setDevice: function(device) {
        this.device = device;
    },

    setSource: function(source) {
        this.source = source;
    },

    setClientVersion: function(version) {
        this.clientVersion = version;
    },

    setScriptVersion: function(version) {
        this.scriptVersion = version;
    },

    setKeychain: function(keychain) {
        this.keychain = keychain;
    },

    setConsumerKey: function (key) {
        this.consumerKey = key;
    },

    setParam: function(param, value) {
        this.params[param] = value;
    },

    setErrorFilter: function(callback) {
        this.errorFilter = callback;
    },

    setSuccessFilter: function(callback) {
        this.successFilter = callback;
    },

    setupRequestParams: function() {
        var params = {
            src: this.source,
            device: this.device,
            v: this.clientVersion,
            sv: this.scriptVersion,
            x_su_consumer_key: this.consumerKey
        };

        return params;
    },

    setAuth: function(authString) {
        this.keychain.authString = authString;
    },

    /** request-related **/
    makeRequest: function(params, callbackSuccess, callbackError) {
        var connector = new this.connectorClass();
        var request   = new SU_ClientRequest();
        if (params.action && params.action == 'getState') {
//            request.async = false;
        }
        var postActions = { 'logoutWebsite': true,
                'send': true,
                'timers': true
                };
        if (params.action && (params.action in postActions)) {
            request.type = 'POST';
        }

        request.params = this.setupRequestParams();
        for (var key in params) {
            request.params[key] = params[key];
        }

        // Note:  There is a special-case where if a callback isn't supplied, the caller gets a direct
        //        response of a url to navigate to (yuck! @todo: change this).  So we don't filter these types of
        //        direct navigation approaches (thus the check on callbackSuccess)
        var instance = this;
        var fnSuccess = callbackSuccess;
        if(fnSuccess && this.successFilter)
        {
            fnSuccess = function(response) {
                if(!instance.successFilter(response, params, callbackSuccess, callbackError) && callbackSuccess)
                    callbackSuccess(response);
            }
        }

        var fnInternalErrorHandler = function(response) {
            // Our own error handler
            if (instance.handleErrorResponse(response, params, callbackSuccess, callbackError))
                return;

            var fnError = callbackError;
            if (this.errorFilter)
            {
                fnError = function(response) {
                    if(!instance.errorFilter(response, params, callbackSuccess, callbackError) && callbackError)
                        callbackError(response);
                }
            }
            if (fnError)
                fnError(response);
        }

        return connector.getResponse(request, this.keychain, fnSuccess, fnInternalErrorHandler);
    },

    handleErrorResponse: function(response, params, fnSuccess, fnError) {
        if(this.inAuthRetry || (response.status != 401) || (params.action == 'getOAuthToken'))
        {
            // No retry, just let them handle the error
            return false;
        }

        var instance = this;
        this.inAuthRetry = true;
        var fnDoneAuthRetry = function(fnCallback) {
            // Don't hammer us, cool your jets
            window.setTimeout(function() {
                instance.inAuthRetry = false;
            }, instance.AUTH_RETRY_WAIT);
        }
        var fnRetrySuccess = function(response2) {
            fnDoneAuthRetry();
            if(fnSuccess)
                fnSuccess(response2);
        }
        var fnRetryFailure = function(response2) {
            fnDoneAuthRetry();
            if(fnError)
                fnError(response2);
        }
        var fnStateSuccess = function() {
            // We were able to refresh the state, try the original call again
            instance.makeRequest(params, fnRetrySuccess, fnRetryFailure);
        }
        // If we can't refresh our state then report the _original_ failure
        var fnStateFailed = function() {
            fnDoneAuthRetry();
            if(fnError)
                fnError(response);
        }
        // Kick off the retry by refreshing our state. If state refreshing failed, try getting an oauth token
        if (params.action == 'getState')
            this.getOAuthToken(fnStateSuccess, fnStateFailed);
        else
            this.getState(fnStateSuccess, fnStateFailed);

        // true == we handled it
        return true;
    }
}

/**
 * API Connector
 *   - handles connecting client API and SU server API via ajax requests
 *   - intended to be highly naive and light
 *   - intended to be swapped out for REST API connector soon
 */
var SU_ClientApiConnector = function() {

    //define endpoints for each action.
    //RESTful Connector will specify many more and more verbosely
    this.endpoints = {
        stumble: "/su/api/nextstumble",
        referral: "/su/api/nextstumble",
        logoutWebsite: "/toolbar/loginservices.php",
        send: "/toolbar/shareservices.php",
        def: "/su/api/action",
        getState: "/su/api/getState",
        getOAuthToken: "/su/api/getOAuthToken",
        startSession: "/su/api/startSession"
    }

    this.getResponse = function(request, keychain, callback, callbackError) {

        if (!keychain) {
            throw "Must provide credentials for request";
        }

        var endpoint = this.endpoints.def;
        if (typeof request.params.action != "undefined")
        {
            if (typeof this.endpoints[request.params.action] != "undefined") {
                endpoint = this.endpoints[request.params.action];
            }
        }

        if (keychain.authString) {
            request.params.auth = keychain.authString;
        }

        if (keychain.OAuth != undefined && keychain.OAuth != null && keychain.OAuth.key != undefined) {
            request.params.x_su_access_token_key = keychain.OAuth.key;
        }

        if (typeof request.params.action != "undefined" && request.params.action == "stumble") {
            request.params._token = keychain.tokens.stumble;
        }
        else {
            request.params._token = keychain.tokens.request;
        }

        if (callback)
        {
            if  (!callbackError)
                callbackError = function() {}
            request.params.output = 'json';
            $.ajax({
                url: endpoint,
                type: request.type,
                data: request.params,
                dataType: 'json',
                async: request.async,
                success: callback,
                error: callbackError
            });
        }
        else
        {
            var query_string = [];
            for (var key in request.params) {
                query_string.push(key + '=' + encodeURIComponent(request.params[key]));
            }
            return endpoint + '?' + query_string.join("&");
        }
    }
}

/**
 * REST API Connector
 *   - will replace deprecated API connector in near future
 *   - will be slightly less naive than deprecated one, since RESTful (one endpoint per call type)
 */
var SU_ClientApiConnector_REST = function() {
    this.endpoints = {
        stumble: '',
        rate: '',
        getTopics: ''
    }
}
SU_ClientApiConnector_REST.prototype = new SU_ClientApiConnector();

/**
 * Request convenience class
 */
var SU_ClientRequest = function() {

    this.type = "GET";
    this.params = {};
    this.async = true;

    this.defaultParams = {
        src : 'litebar'
    }
};/**
 * su_extensionapi_webtb.js
 *
 * Implements the suExtensionApi for the webtb
 */
(function() {
    SU.SuExtensionApiWebTb = function() {
        this.message._listeners = [];
    };

    SU.SuExtensionApiWebTb.prototype = {
        // -------------------------------------------------------------------
        // Extension information
        // -------------------------------------------------------------------
        _info: { apiVersion: "1.0",    provider: "webtb", _providerVersion: "1.0" },
        id: 1,

        getProviderInfo: function(callback) {
            callback(this._info);
        },

        isReady: function() { return true; },

        // -------------------------------------------------------------------
        // Message functionality
        // -------------------------------------------------------------------
        message: {
            addListener: function(fnListener/*function(messageId, data, sender) { }*/) {
                this.removeListener(fnListener);
                this._listeners.push(fnListener);
            },

            removeListener: function(fnListener) {
                for(var i=0; i<this._listeners.length; i++)
                {
                    if(this._listeners[i] === fnListener)
                    {
                        this._listeners.splice(i, 1);
                        return;
                    }
                }
            },

            broadcastMessage: function(messageId, data) {
                this.postMessage(null, messageId, data);
            },

            postMessage: function(target, messageId, data) {
                for(var i=0; i<this._listeners.length; i++)
                {
                    this._listeners[i](messageId, data, null);
                }
            }
        },

        // -------------------------------------------------------------------
        // Overlay functionality
        // -------------------------------------------------------------------
        overlay: {
            opener: null, /* always null for webtoolbar */
            /*
            _overlayPrototype: {
                opener: null,

                close: function() {},
                getPosition: function(callback) {},
                setPosition: function(position) {}
                // position is of the form { left: n, top: n, width: n, height: n }
            },
            */
            create: function(url, options, callback /*function (overlay)*/) {},

            destroy: function(id) {
                suExtensionApi.message.postMessage(null, 'overlayClose', id);
            }
        }
    };

    SU.addInit("mSuExtensionApiWebTb", function(data) {
        if (typeof suExtensionApi != "undefined")
            return;
        if (typeof top.suExtensionApi != "undefined")
            suExtensionApi = top.suExtensionApi;
        else
            suExtensionApi = top.suExtensionApi = new SU.SuExtensionApiWebTb;
    });
}).call(this);/* Litebar client Implementation
 *   - speaks to Client API
 *   - implementation class
 *   - extended by webtoolbar and chrome
 */
var SU_ClientLitebar = function() {
    this.api              = new SU_Client();
    this.currentStumble   = null;
    this.currentStaticUrl = null;
    this.currentUser      = null;
    this.sidecarData      = null;
    this.consumerKey      = '';

    this._globals          = null;

    // The SidePanel (/js/sidepanel.js)
    this.sidepanel  = null;
    this.errorState = null;

    this.keychain = new SU_ClientRequestKeychain();

    this.credentialsFetchedTime = 0;

    this.data = {};

    this.timers = null;

    this._implicationData = {};

    this.overlayManager = null;

    this.delayedTooltips = {};
    this.notificationCloseTimeout = 0;

    this.overlaysPreloaded = false;

    this.mobileBrowser = false;

    this.ready = false;

    this.triggeredAdBlockCheck = false;
    this.initiallyHasIframe    = false;

    this.mediator = require("module/mediator");

    // TODO:Haroun: IMO urls should be set from a config or calling page if possible. Let's discuss. Imagine a day when our js is not rendered by smarty, how would we pass this data to the js? I know site has this issue - it's being discussed.
    //Pranay: seems like this should be a separate change since it's not related to this project and is a "very big change"...adding a todo
    this.loginUrl = "/login";

    // TODO: Those messages should be in their own file in the future
    this.messages = {
        genericError: "The selected action could not be completed due to a network error (%1). Please try again.",
        loggedOut: "You have been signed out from StumbleUpon.",
        notDiscoveredNoThumbUpMore: "Nobody has discovered this page yet, so you cannot use extended options.",
        notDiscoveredNoThumbDown: "Nobody has discovered this page yet, so it cannot be thumbed down.",
        notDiscoveredNoUrlInfo: "Nobody has discovered this page yet, so we don't have information for this page.",
        hideStumbleBadFlashMessage: "For a better experience, we've temporarily hidden the page until you close the menu. <a href='/help/trouble/stumbling' target='_blank'>Learn more</a>.",
        notLoggedInNoStumble: "You must sign in to stumble. <a href='/login' target='_top'>Click here to sign in</a>.",
        nonRateable: "This page cannot be rated",
        nonShareable: "This page cannot be shared"
    };

    this.notLikeMoreHeight     = 169;
    this.urlInfoHeight         = 415;
    this.shareMenuHeight       = 412;
    this.notificationMenuWidth = 220;

    // URLs that we know are not rateable or shareable (the server may know of others)
    // about:blank is what we get with safaribar for unsupported url types
    this.nonRateableRegex = this.nonShareableRegex = /^about:blank/;

    return true;
};

SU_ClientLitebar.prototype = {

    init: function(globals, stumbleInfo) {
        if (globals) {
            this._globals = globals;

            if (globals.user && globals.user.loggedIn) {
                this.setActiveUser(globals.user);
            }
        }

        this.viewer = globals.viewer;

        // Detect mobile browsers that don't handle iframe correctly
        var ua = navigator.userAgent;
        var checker = {
            iphone: ua.match(/(iPhone|iPod|iPad)/),
            blackberry: ua.match(/BlackBerry/),
            android: ua.match(/Android/)
        };
        this.mobileBrowser = checker.iphone;
        if (this.mobileBrowser) {
            $('#tb-stumble-container').css('position', 'static');
            $("body").addClass("tb-fixed");
        }

        // Workaround for safari bug on back button
        $(window).unload( function() {} );

        this.bindListeners();

        this.clientVersion = globals.clientVersion;

        if ( typeof(suOverlayManager) !== "undefined" ) {
            this.overlayManager = new suOverlayManager(this, this.clientVersion);
        }

        // Install the resize window handler
        this.installResizeHandler();

        if (stumbleInfo) {
            this.setActiveStumble(stumbleInfo);
            this.handleSidecarData(stumbleInfo);

            if (stumbleInfo.progress) {
                this.showProgress(stumbleInfo.progress);
            }

            if (stumbleInfo.reveal) {
                this.initProgressiveReveal(stumbleInfo.reveal);
            }

            if (stumbleInfo.firstStumble) {
                this.initTutorial();
            }
        }

        // Set up the api
        this.setupApi();
        // Finally, update the UI
        this.updateUI();

        this.initTimers();

        // IE8- does not have createEvent
        if (document.createEvent) {
            var scriptReadyEvent = document.createEvent("Event");
            scriptReadyEvent.initEvent("suScriptReadyWebToolbar", false, false);
            window.dispatchEvent(scriptReadyEvent);
        }

        this.ready = true;
    },

    initTutorial: function() {
        var ToolbarTutorialView = require("module/views/toolbar_tutorial_view"),
            view;

        view = new ToolbarTutorialView({
            className: "toolbar-tutorial fadeOut",
            currentStumble: this.currentStumble
        });
        $("body").append(view.$el);
    },

    initProgressiveReveal: function(state) {
        var RevealTooltipView = require("module/views/reveal_tooltip_view"),
            steps = require("tutorialSequences")[state.sequence],
            step,
            $target,
            id;

        for (var key in steps) {
            step = steps[key];
            $target = $("#" + step.id);
            if (key == state.current) {
                if (step.fn) {
                    this[step.fn].call(this);
                } else {
                    new RevealTooltipView({
                        el: $("body"),
                        data: step
                    });
                }
            } else if (key > state.current) {
                $target.hide();
            }
        }
    },

    isReady: function() {
        return this.ready;
    },

    installResizeHandler: function() {
        var instance = this;
        $(window).resize(function() {
            instance.onResize();
        });
        this.onResize();
    },

    initTimers: function() {
        if (!this.timers) {
            this.timers = new SU_Timers();
            this.timers.init();
            var instance = this;

            if (this.timers.enabled) {
                // Check if we need to send timers for the saved/previous stumbles
                var saved_timers = this.timers.getSavedTimers();
                if (saved_timers) {
                    // Send locally saved timers to server
                    if (instance.currentUser && instance.currentUser.uid
                            && instance.currentUser.loggedIn
                            && instance.currentUser.uid == saved_timers.uid
                            && instance.currentUser.uid > 15041000) {
                        instance.api.saveTimers(saved_timers.pid, saved_timers.data);
                    }
                }

                // Add the event handler to save the info when page is unloaded
                $(window).unload( function() {
                    instance.timers.addEvent('interrupted');
                    instance.timers.saveTimersToDOMStorage();
                });
            }
        }
    },

    getToolbarHeight: function() {
        return $('#tb-toolbar').height();
    },

    onResize: function() {
        // Resize the possible opened overlays
        if (this.overlayManager)
        {
            var oSpaces = this.overlayManager.onResize();
            var h = this.getToolbarHeight();
        }
        else // When chromebar installed
        {
            var oSpaces = {top: 0, right: 0, bottom: 0, left: 0};
            var h = 40; /* v5 chromebar size */
        }

        // Resize the stumble container if present

        var winH = $(window).height();
        var disableDiv = $('#tb-stumble-disable');
        disableDiv.css('height', (winH - h));
        var container = $('#tb-stumble-container');
        if (!this.mobileBrowser && container.length > 0)
        {
            container.css('height', ($(window).height() - h - oSpaces.top - oSpaces.bottom));
            container.css('top', oSpaces.top + 'px');
        }
    },

    /*
     * onStumblePageLoading
     *
     * Called when we know we have a currentStumble and it is loading.
    */
    onStumblePageLoading: function() {
        if( this.currentStumble && this.currentStumble.guess ){this.preloadNextStumble( this.currentStumble.guess );}
    },

    onStumblePageLoaded: function() {
        if (this.timers) {
            this.timers.addEvent('pageLoaded');
        }
    },

    bindListeners: function() {
        var instance = this;
        suExtensionApi.message.addListener(function(messageId, data, sender) {
            instance.onMessage(messageId, data, sender);
        });

        var uiEvent;
        for (var evt in this.userInterfaceEvents) {
            uiEvent = this.userInterfaceEvents[evt];
            $(uiEvent.target).bind(uiEvent.action, {instance: this}, uiEvent.handler);
        }
    },

    /*
     * Local user data is per-user data that is stored on the local client and shared
     * amongst all toolbars.  Data stored as local user data is automatically deleted
     * when the current user changes.
     *
    */
    getLocalUserData: function() {
        return this._globals.localUserData;
    },

    updateUrlData: function(urlData) {
        // Implement in derived class, default webbar doesn't persist url data
    },

    // Use for read-only access to current globals.
    // Use updateGlobal to update global properties
    getGlobals: function() {
        return this._globals;
    },

    getState: function(fnSuccess, fnFailure) {
        //  Our api success filter deals with the getState response
        this.api.getState(fnSuccess, fnFailure);
    },

    showProgress: function(state) {
        var ProgressBar = require("module/progress_bar"),
            progress;

        if (state) {
            progress = new ProgressBar(state);

            this.overlayManager.openOverlay('context-panel', {
                type: 'top',
                size: {height: 90},
                closeOthers: ['floating', 'notification'],
                refresh: true,
                data: progress.$el.html()
            });
        }

    },

    // Updates globals with the values that are passed.
    // Also purges any per-user data if the user changes.
    //
    updateGlobals: function(newValues) {
        // Start with the current globals
        var globals = jQuery.extend({}, this._globals);
        var newUser = false;
        if (newValues.user) {
            // They supplied a new user value, check whether it's a change
            if (!globals.user) {
                newUser = true;
            } else if (newValues.user.userid != globals.user.userid) {
                newUser = true;
            }
        }

        if(newUser)
        {
            globals.token = {};
            globals.localUserData = {};
            globals.state = {};
        }

        // Merge the new values and update
        globals = jQuery.extend({}, globals, newValues);
        this.updateAllGlobals(globals, false);
    },

    updateAllGlobals: function(newGlobals, fromExternal) {
        if (JSON.stringify(newGlobals) == JSON.stringify(this._globals)) {
            return;
        }

        this._globals = newGlobals;
        this.onGlobalsUpdated(fromExternal);
    },

    // Called whenever global state has been changed.
    // It will update the UI.  Override to do additional processing, for example
    // if you need to store the globals and/or notify other endpoints about the change
    onGlobalsUpdated: function(fromExternal) {
        // @todo:  This is temporary, we shouldn't be storing the user separately.
        if (this._globals) {
            this.setActiveUser(this._globals.user);
        } else {
            this.setActiveUser({
                loggedIn: false
            });
        }

        if (this._globals && this.api) {
            var keychain            = new SU_ClientRequestKeychain();
            if(this._globals.token) {
                keychain.tokens.stumble = this._globals.token.stumble;
                keychain.tokens.request = this._globals.token.ajax;
            }
            keychain.OAuth          = this._globals.oAuth;
            this.api.setKeychain(keychain);
        }

        this.updateUI();
    },

    onMessage: function(messageId, data, sender) {
        switch (messageId) {
            case 'doStumble':
                // referralNavigate was added to chrombar in build 5.3.5.1, use the
                // old _referralNavigate in older extensions, and just navigate
                // as a last resort (really old extensions).
                if (suExtensionApi.litebar.referralNavigate)
                    suExtensionApi.litebar.referralNavigate(data);
                else if (suExtensionApi._referralNavigate)
                    suExtensionApi._referralNavigate(data);
                else
                    suExtensionApi.litebar.setContentLocation(data);
                this.finishStumble();
                break;
            case 'handleImplication':
                this.handleImplication(data);
                break;
            case 'implicationSubmit':
                this.implicationSubmit(data);
                break;
            case 'stumbleStarted':
                this.preupdateUI_Stumble();
                break;
            //todo: remove this autoshared message crap in a bit..added in on 02/02
            case 'autosharepopupoptout':
                var target = data.targetlink;
                var token = data.token;
                Sync(target).update({
                    _token:token
                });
                break;
            case 'displayNotification':
                this.displayNotification(data);
                break;
            case 'externalModeSelect':
                this.logEvent('change-mode');
                this.setStumbleState(data);
                break;
            case 'overlayClose':
                if ( this.overlayManager ) {
                    this.overlayManager.closeOverlay(data);
                }
                break;
            case 'overlayDestroy':
                if (this.overlayManager){this.overlayManager.destroyOverlay(data);}
                break;
            case 'rate':
                if (this.currentStumble.publicid == data.pid
                        && $.inArray(data.rating, [1, 0, -1]) != -1){this.performRating(data.rating);}
                break;
            case 'refreshState':
                var instance = this;
                this.getRequestToken(function (response) {
                        // Check if login state changed
                        if (instance.currentUser.loggedIn != response.user.loggedIn
                                || (instance.currentUser.loggedIn && instance.currentUser.username != response.user.username)) {
                            if (!response.user.loggedIn) {
                                instance.overlayManager.destroyAllOverlays();
                                instance.displayNotification({
                                    type: 'error',
                                    message: instance.messages.loggedOut,
                                    delay: 8000
                                });
                            }
                            instance.setActiveUser(response.user);
                        }
                    });
                break;
            case 'resizePanel':
                if ( this.overlayManager ) {
                    this.overlayManager.repositionOverlay(data.id, data.size);
                }
                break;
            case 'hideToolbar':
                var instance = this;
                if (data && data.hidePermanent) {
                    // Do an ajax hit
                    $.ajax({
                        url: '/su/api/hideToolbarPerm',
                        data: data,
                        type: 'POST',
                        complete: function() {instance.hideToolbar();}
                    });
                } else {
                    this.hideToolbar();
                }
                break;
            case 'showMessageOverlay':
                this.displayMessageOverlay(data);
                break;
            case 'showShareMessageReply':
                // Display the share extended panel
                url = '/su/overlay/sharemsgreply?sharepid=' + encodeURIComponent(data);
                if (this.overlayManager) {
                    this.overlayManager.toggleOverlay('share-panel-reply', {
                        url: url,
                        type: 'floating',
                        size: {width: 508, height: 391},
                        closeOthers: ['floating', 'notification'],
                        refresh: true
                    });
                }
                break;
            case 'showSharePanel':
                if (data.pid) {
                    this.showSharePanel(data.pid);
                } else if (data.url) {
                    this.showSharePanel(null, data.url);
                }
                break;
            case 'showAddToList':
                this.toggleLists();
                break;
            case 'stumbleNow':
                this.performStumble();
                if (this.overlayManager) {
                    this.overlayManager.closeOtherOverlays(null, ['floating']);
                }
                break;
            case 'thumbDownMenu_blocksite':
                this.performBlockSite(data.pid, data.blocksite);
                if (this.overlayManager) {
                    this.overlayManager.closeOverlay('thumbdown-menu');
                }
                break;
            case 'thumbDownMenu_subrate':
                this.performSubRating(data.subrating);
                if (this.overlayManager) {
                    this.overlayManager.closeOverlay('thumbdown-menu');
                }
                break;
            case 'closeOtherOverlays':
                if (this.overlayManager) {
                    this.overlayManager.closeOtherOverlays(data.overlayid, data.others);
                }
                break;
            case 'updateRating':
                this.currentStumble.rating = data.rating;
                this.updateUrlData({ url: this.currentStumble.url, rating: data.rating });
                this.updateUI();
                break;
        }
    },

    displayMessageOverlay: function(message) {
        if (message.options.type == 'permanenttooltip'){message.options.data = '<a href="#" onclick="javascript:suExtensionApi.message.postMessage(null, \'overlayClose\', \'' + message.id + '\');return false;">Ã—</a>'
                               + message.options.data;}
        if (message.anchor) {
            message.options.anchorElement = $('#' + message.anchor);
            if (message.options.anchorElement.length == 0) {
                return;
            }
        }

        if (this.overlayManager) {
            if (message.options.overlayType === 'notification') {
                this.displayNotification(message.options);
            } else if (message.id === "producttour") {
                // No-op.  In this toolbar, this case is handled by initTutorial().
            } else {
                this.overlayManager.openOverlay(message.id, message.options);
            }
        }
    },

    displayNotification: function(data /*js object: type, message, delay -optional default to 4 seconds*/) {
        if (this.overlayManager) {
            this.overlayManager.openOverlay('notification-bar', {
                type: 'notification',
                notificationType: data.type,
                data: data.message,
                size: {'max-width': 500},
                refresh: true
            });
            if (this.notificationCloseTimeout) {
                clearTimeout(this.notificationCloseTimeout);
            }
            var instance = this;
            this.notificationCloseTimeout = setTimeout(function() {
                instance.overlayManager.closeOverlay('notification-bar');
                instance.notificationCloseTimeout = 0;
            }, data.delay ? data.delay : 4000);
        }
    },

    setData: function(key, data, callback) {
        throw "Must implement setData in implementation class";
    },

    getData: function(key, callback) {
        throw "Must implement getData in implementation class";
    },

    setKeychain: function(keychain) {
        this.keychain = keychain;
        this.setData('keychain', keychain);
    },

    handleSidecarData: function(response) {
        if (!response || typeof response.auxData == "undefined") {
            return false;
        }

        this.sidecarData = response.auxData;
        if (typeof response.auxData.updateClient != "undefined") {
            this.setData('performClientUpdate', 1);
        }
    },

    setAuth: function(authString) {
        this.keychain.authString = authString;
    },

    setupApi: function() {
        // Prime the api with our parameters
        this.api.setDevice(this.device);
        this.api.setSource(this.source);
        this.api.setConsumerKey(this.consumerKey);

        // Build a keychain with the tokens and give it to the api
        // @todo:  combine the authstring which should also be in the globals
        // @todo:  Also, this should be done during global update processing
        var globals = this.getGlobals();
        if (globals.token) {
            var keychain = new SU_ClientRequestKeychain();
            keychain.tokens.stumble = globals.token.stumble;
            keychain.tokens.request = globals.token.ajax;
            keychain.OAuth = globals.oAuth;
            this.api.setKeychain(keychain);
        }

        if (typeof this.clientVersion != "undefined") {
            this.api.setClientVersion(this.clientVersion);
        }
        this.api.setScriptVersion(this.scriptVersion);

        var instance = this;
        this.api.setErrorFilter(function(response, params, fnSuccess, fnError) {
            return instance.filterApiError(response, params, fnSuccess, fnError);
        });

        this.api.setSuccessFilter(function(response, params, fnSuccess, fnError) {
            return instance.filterApiSuccess(response, params, fnSuccess, fnError);
        });
    },

    filterApiSuccess: function(response, params, fnSuccess, fnError) {
        // getState is called implicitly by the API so we handle the response here
        if(params.action == 'getState')
        {
            var newGlobals = {
                token: response.token,
                user: response.user,
                clientVersion: response.clientVersion,
                shares: response.shares
            };

            if (!response.user || !response.user.loggedIn) {
                newGlobals.oAuth = null;
            }

            this.updateGlobals(newGlobals);

            // If we have shares, update the share info
            if(newGlobals.shares){this.getShareInfo();}

            // Allow it to continue to be processed
            return false;
        }

        if(params.action == 'getOAuthToken')
        {
            this.updateGlobals({
                oAuth: response.token
            });
        }
    },

    filterApiError: function(response, params, fnSuccess, fnError) {
        // Display an error for any failed API call
        var msg = this.messages.genericError.replace('%1', response.status);
        this.displayNotification({
            type: 'error',
            message: msg,
            delay: 10000
        });
        return false;
    },

    performShareStumble: function(callback) {
        var instance = this;

        this.setActiveStumble(null);
        this.setActiveStaticUrl(null);
        instance.api.getShare(function(response) {
            instance.setActiveStumble(response);
            instance.handleSidecarData(response);
            instance.updateUI();
            if (callback) {
                callback(response);
            }
        });
    },

    finishStumble: function() {
        // webbar and chromebar perform a top-level navigation.
        // No work to do since we're going to be reloaded anyhow
    },

    performStumble: function(callback, nextpid) {
        var instance = this,
            newMode = this._globals.state;

        if (this.stumblePending) {
            return false;
        }
        this.stumblePending = true;

        this.preupdateUI_Stumble();

        if (nextpid) {
            newMode.nextpid = nextpid;
        }

        if (this.ratingInProgress) {
            this.mediator.on("rating:completed", completeStumble);
        } else {
            completeStumble();
        }

        function completeStumble() {
            instance.mediator.off("rating:completed", completeStumble);
            if (suExtensionApi.stumble) {
                suExtensionApi.stumble.stumble(false, false, function(result) {
                    instance.finishStumble();
                });
            } else {
                instance.performStumbleDirect(newMode, function(url) {
                    instance.gotoUrl(url);
                });
            }
        }
    },

    preupdateUI_Stumble: function() {
        $('#tb-stumble').addClass('tb-active');
        this.beginStumbleAnimation();
        if (this.overlayManager) {
            this.overlayManager.closeAllOverlays();
        }
    },

    beginStumbleAnimation: function() {
        var instance = this,
            selector = $('#tb-stumble a');

        if (this.stumbleAnimationActive) {
            return;
        }

        this.stumbleAnimPos = 0;
        this.stumbleAnimationActive = true;
        selector.addClass("tb-stumble-anim");
        var interval = window.setInterval(function() {
            if (!instance.stumbleAnimationActive) {
                window.clearInterval(interval);
                return;
            }

            selector.removeClass("tb-stumble-anim-" + instance.stumbleAnimPos);

            instance.stumbleAnimPos++;
            if (instance.stumbleAnimPos == 6) {
                instance.stumbleAnimPos = 1;
            }

            selector.addClass("tb-stumble-anim-" + instance.stumbleAnimPos);
        }, 350);
    },

    endStumbleAnimation: function() {
        if (!this.stumbleAnimationActive) {
            return;
        }
        this.stumbleAnimationActive = false;

        // Remove the animation class name
        var selector = $('#tb-stumble .tb-btn-ico');
        selector[0].className = 'tb-btn-ico';
    },

    //instead of ajax, a 301-based solution
    performStumbleDirect: function(extraParams, callback) {
        var instance = this;
        this.setActiveStumble(null);
        this.setActiveStaticUrl(null);
        var params = instance._globals.state;
        if (extraParams)
        {
            for (var i in extraParams)
            {
                params[i] = extraParams[i];
            }
        }
        // Save "stumbleRequest" timestamp for next stumble
        params['stumbleRequest'] = new Date().getTime();
        if (instance.timers) {
            // Save possible timers for this current stumble
            // they will be sent to the server on the next stumble
            instance.timers.addEvent('nextStumbleClick');
            instance.timers.saveTimersToDOMStorage();
        }
        var url = instance.api.getStumble(params);
        callback(url);
//        return this.api.getStumble(params);
    },

    performRating: function(rating) {
        var instance = this;
        if (instance.currentStumble) {
            if (typeof instance.currentStumble.rating != "undefined") {
                instance.currentStumble.previousRating = instance.currentStumble.rating;
            }

            if (typeof instance.currentStumble.rating != "undefined" && instance.currentStumble.rating == rating) {
                rating = -1;
            }

            instance.ratingInProgress = true;
            instance.overlayManager.closeOverlay('implication');

            var callback = function(response) { instance.ratingCallback(response); }
            var callbackError = function(jqXHR, textStatus, errorThrown) { instance.ratingCallbackError(jqXHR, textStatus, errorThrown); }
            instance.api.rate(instance.currentStumble.publicid, rating, callback, instance.currentStumble.autosharedToFacebook, callbackError);
            instance.currentStumble.rating = rating;
            instance.updateUrlData({ url: instance.currentStumble.url, rating: rating });
            instance.updateUI();

        }
    },

    performSubRating: function(subrating, callback) {
        var instance = this;
        if (instance.currentStumble)
        {
            if (typeof instance.currentStumble.subrating != "undefined" && instance.currentStumble.subrating == subrating) {
                subrating = 0;
            }

            instance.api.subrate(instance.currentStumble.publicid, subrating, callback);
            instance.currentStumble.subrating = subrating;
            // When subrating, we also change the rating to "Not Like"
            if (subrating < 0){instance.currentStumble.rating = 0;} else {instance.currentStumble.rating = -1;}
            instance.updateUI();
        }
    },

    performBlockSite: function(pid, blocksite/*1 to block 0 to unblock*/, callback) {
        var instance = this;
        instance.api.blocksite(instance.currentStumble.publicid, blocksite, callback);
    },

    getRequestToken: function(callback) {
        this.setupApi();
        var instance = this;
        this.api.getRequestToken(function(response) {
            if (callback) {
                callback(response);
            }
        });
    },

    trk: function(metric) {
        // TODO for v5 metrics
        //this.api.trk(metric, function() {});
    },

    showSidePanel: function(stumbler, url, force) {
        // Must be implemented by derived class
    },

    hideSidePanel: function(stumbler, url) {
        // Must be implemented by derived class
    },

    resetStumbleState: function(callback) {
        this.updateGlobals({ state: {} });
    },

    setStumbleState: function(state, callback) {
        this.updateGlobals({ state: state });
    },

    getStumbleState: function() {
        if (this._globals.state) {
            return this._globals.state;
        } else {
            return {};
        }
    },

    getActiveStumble: function() {
        return this.currentStumble;
    },

    // TODO:  Replace legacy webbar stumble data handling with a proper data access layer, it is too fragile.
    setActiveStumble: function(stumbleInfo) {
        var oldInfo = this.currentStumble;
        // Don't do anything if there wasn't a material change
        if (_.isEqual(oldInfo, stumbleInfo)) {
            return;
        }

        if (this.timers && this.timers.enabled
                && stumbleInfo && stumbleInfo.publicid
                && this.currentUser && this.currentUser.uid && this.currentUser.uid > 0) {
            this.timers.setPidAndUid(stumbleInfo.publicid, this.currentUser.uid);
            if (this.timers.hasEvent('stumbleRequest') == false) {
                // Try to retrieve the "stumbleRequest" from the cookie set by "/toolbar/next_stumble.php"
                var cookie = new SU.Cookie('savedStumbleRequest', '1');
                cookie.read();
                var values = cookie.value ? cookie.value.split('|') : [];
                if (values != null && values.length == 2 && values[0] == stumbleInfo.publicid) {
                    this.timers.addEvent('stumbleRequest', values[1]);
                }
            }
        }

        // Display a possible permanent tooltip
        var globals = this.getGlobals();
        if (globals.messageOverlay)
        {
            var message = globals.messageOverlay;
            delete globals.messageOverlay;
            this.displayMessageOverlay(message);
        }

        // Preload the interests panel for logged users
        if (this.currentUser && !this.overlaysPreloaded) {
            this.toggleInterestsPanel(true);
            this.overlaysPreloaded = true;
        }

        this.currentStaticUrl = null;
        // If this is the same URL, then just extend any of our local state data with new data.  Otherwise,
        // we still use jQuery.extend to create our own copy of the object.  This arises because old chromebar
        // doesn't persist stumble data like ratings.
        if (this.currentStumble && stumbleInfo && this.currentStumble.url && (this.currentStumble.url == stumbleInfo.url)){this.currentStumble = jQuery.extend({}, this.currentStumble, stumbleInfo);} else {this.currentStumble = jQuery.extend({}, stumbleInfo);}
        if (this.currentStumble && this.overlayManager) {
            if (this.currentStumble.sharePid) {
                // Display the share panel
                url = '/su/overlay/sharemsg?sharepid=' + encodeURIComponent(this.currentStumble.sharePid);
                this.overlayManager.toggleOverlay('share-panel', {
                    url: url,
                    type: 'top',
                    size: {height: 40},
                    closeOthers: ['floating', 'notification'],
                    refresh: true
                });
            } else if (this.currentStumble.context && this.currentStumble.context.templateData) {
                // Display the stumble context panel
                // this.overlayManager.openOverlay('context-panel', {
                //     type: 'top',
                //     size: {height: 40},
                //     closeOthers: ['floating', 'notification'],
                //     refresh: true,
                //     context: this.currentStumble.context
                // });

                if (this.currentStumble.forcedStumbling) {
                    // @TODO require stub
                    // @todo Rename this to something other than forcedStumbling
                    // if the AB test is successful.
                    var ProgressBar = require("module/progress_bar"),
                        forcedStumbling = this.currentStumble.forcedStumbling;

                    this.currentStumble.progress = new ProgressBar({
                        el: "#progressBar",
                        progress: forcedStumbling.progress,
                        max: forcedStumbling.maxProgress,
                        message: forcedStumbling.progressMessage,
                        progressText: forcedStumbling.progressStatusMessage
                    });

                    this.mediator.on("thumbDown thumbUp", this.enableStumbling, this);
                    this.enableForceStumbling();
                }
            }
        }

        if (this.currentStumble && this.currentStumble.loginUrl) {
            this.updateLoginUrl(this.currentStumble.loginUrl);
        }

        this.updateUI_StumbleMeta();

        // Preload the next stumble if there is one
        if (stumbleInfo) {
            this.onStumblePageLoading();
        }
    },

    updateLoginUrl: function(newUrl) {
        this.loginUrl = newUrl;
    },

    setActiveStaticUrl: function(staticUrl) {
        this.currentStumble   = null;
        this.currentStaticUrl = staticUrl;
    },

    setActiveUser: function(user) {
        // @todo:  This is reundant with globals.user, we shouldn't be duplicating this
        this.currentUser = user;
    },

    setModeLabel: function(label, callback) {
        $('#tb-interests a span.tb-btn-text').html(label);
        this.setData('stumblingModeLabel', label, callback);
    },

    autoShareToFacebook: function(callback) {
        var instance = this;
        if (instance.currentStumble && instance.currentStumble.url && instance.currentStumble.publicid
            && !instance.currentStumble.autosharedToFacebook) {
            instance.api.autoShareFacebook(instance.currentStumble.publicid, instance.currentStumble.url);
            instance.currentStumble.autosharedToFacebook = true;
        }
    },

    showMeMore: function(data) {
        if (data.user_id) {
            this.setStumbleState({
                mode: 'instumbler',
                stumbler: data.user_id
            });
        }
        else if (data.topic_id) {
            this.setStumbleState({
                topic: data.topic_id,
                contextual: data.topic_name
            });
        }
        else if (data.url_domain) {
            this.setStumbleState({
                mode: 'stumblethru',
                partner: data.url_domain,
                contextual: data.url_domain
            });
        }
    },

    preloadNextStumble: function(guess) {
        function doPreload() {
            var link = document.createElement("link");
            link.setAttribute("href", guess);
            link.setAttribute("rel", "prerender");
            $('head').append(link);
        }

        if (document.webkitVisibilityState !== "prerender") {
            doPreload();
        } else {
            document.addEventListener("webkitvisibilitychange", function() {
                if (document.webkitVisibilityState === "visible") {
                    doPreload();
                }
            }, false);
        }
    },

    //descendents must implement updateUI_Error, etc.
    updateUI: function() {

        if (this.errorState) {
            //display error shit
            this.updateUI_Error();
        }

        // Update global state UI elements
        this.updateUI_General();

        // Update rating-related UI elements
        if (this.currentStumble) {
            this.updateUI_StumbleMeta();
        }

        //update user-related UI elements. call no matter what, in case logged out
        this.updateUI_User();

        //todo change these into updateUI_Global() and updateUI_Local()
        //(one for all tabs/windows, the other for just this one)
    },

    updateUI_General: function() {
        // Update the stumble context label
        var state = this.getStumbleState();
        var label = "All Interests";
        if(state.contextual) {
            label = state.contextual;
        } else {
            if ((state.mode == 'instumbler') && state.stumbler) {
                label = state.stumbler + '\'s favorites';
            }
        }
        this.setModeLabel(label);

        // Update the number of referrals
        var numref = 0;
        if (this.currentStumble && this.currentStumble.numreferrals) {
            numref = this.currentStumble.numreferrals;
        }
        this.updateNumReferrals(numref);
    },

    checkForAdBlockAndReport: function () {
        var hasBeenBlocked = false;
        //first check if it still has an iFrame...if it DOES NOT, it has been blocked by ADP for chrome or similar
        var stillHasIframe = (document.getElementById('tb-stumble-frame') != null);

        if (!stillHasIframe) {
            hasBeenBlocked = true;
        } else {
            //now check if clientHeight is 0 (Adblock for chrome and ABP for firefox cause this to be set to 0)
            hasBeenBlocked = (document.getElementById('tb-stumble-frame').clientHeight == 0);
        }

        if (hasBeenBlocked) {
            //now trigger the AJAX call to log the event
            $.ajax({
                url: '/su/api/action',
                data: {
                    _token: this._globals.token.ajax,
                    _action: 'adblockDetected',
                    pid: this.currentStumble.publicid,
                    url: this.currentStumble.url
                },
                type: 'POST'
            });
        }
    },

    updateUI_StumbleMeta: function() {
        if (this.currentStumble && typeof this.currentStumble.rating != "undefined") {
            if (this.currentStumble.rating == 1) {
                $('#tb-toolbar').removeClass('tb-thumbeddown').addClass('tb-thumbedup');
            }
            else if (this.currentStumble.rating == 0) {
                $('#tb-toolbar').removeClass('tb-thumbedup').addClass('tb-thumbeddown');
            }
            else {
                $('#tb-toolbar').removeClass('tb-thumbedup tb-thumbeddown');
            }
        }
        else {
            $('#tb-toolbar').removeClass('tb-thumbedup tb-thumbeddown');
        }

        // Update sponsored label
        if (this.currentStumble && this.currentStumble.sponsored) {
            //this code runs twice for some reason; hence, adding a flag to ensure we don't do this twice
            if (!this.triggeredAdBlockCheck) {
                this.triggeredAdBlockCheck = true;
                //some ad block extensions (ad block plus on chrome) remove the iFrame altogether.
                //we cannot assume that if the iFrame is missing then it's being blocked, since chromebar runs through this code, but hsa no iFrame
                //hence, we'll check if the iFrame was initially existing at this point, and then is missing after window load
                this.initiallyHasIframe = (document.getElementById('tb-stumble-frame') != null);
                //only if it initially has an iFrame, we care to check further (after window load)
                //chromebar/mozbar etc don't ever have an iframe, and adblock doesn't affect them
                if (this.initiallyHasIframe) {
                    var instance = this;
                    $(document).ready(function() {
                        //MUST add a .5 sec delay, since adblock might have not kicked in and done it's thing yet...
                        //was inconsistent without it...tested
                        setTimeout(function(){
                            instance.checkForAdBlockAndReport();
                        }, 500);
                    });
                }
            }
            $('#tb-toolbar').addClass('tb-stumble-sponsored');
        } else {
            $('#tb-toolbar').removeClass('tb-stumble-sponsored');
        }

        // Update user label
        var userlabeltext = '';
        var userlabelurl = null;
        var discoverer = null;
        var channel = null;
        var friend = (this.currentStumble && this.currentStumble.friend) ? this.currentStumble.friend : null;
        if (friend == null)
        {
            channel = (this.currentStumble && this.currentStumble.channel) ? this.currentStumble.channel : null;
            if (channel == null) {
                discoverer = (this.currentStumble && this.currentStumble.discoverer) ? this.currentStumble.discoverer : null;
            }
        }
        if (friend || discoverer || channel) {
            if (friend)
            {
                $('#tb-toolbar').removeClass('tb-stumble-discoverer tb-stumble-channels').addClass('tb-stumble-friend');
                userlabeltext = friend.username;
                userlabelurl = friend.url;
            }
            else if (channel)
            {
                $('#tb-toolbar').removeClass('tb-stumble-discoverer tb-stumble-friend').addClass('tb-stumble-channels');
                userlabeltext = channel.username.substr(1);
                userlabelurl = channel.url;
            }
            else
            {
                $('#tb-toolbar').removeClass('tb-stumble-friend tb-stumble-channels').addClass('tb-stumble-discoverer');
                userlabeltext = discoverer.username;
                userlabelurl = discoverer.url;
            }
        } else {
            $('#tb-toolbar').removeClass('tb-stumble-discoverer tb-stumble-friend tb-stumble-channels');
        }
        $('#tb-userlabel a span.tb-btn-text').text(userlabeltext);
        $('#tb-userlabel a').attr('href', userlabelurl ? userlabelurl : '#');
        if (userlabelurl) {
            $('#tb-userlabel a').attr('target', '_blank');
        } else {
            $('#tb-userlabel a').removeAttr('target');
        }

        if (this.currentStumble && this.currentStumble.discoverer_nick) {
            $('#friends').show();
            $('#friends a').show();
            $('#friends a').html('<span></span>' + this.currentStumble.discoverer_nick);
            $('#friends a').attr('href', '/stumbler/' + this.currentStumble.discoverer_nick + '/');
            $('#friends a').attr('target', '_blank');
            if (!this.currentStumble.is_subscription) {
                $('#friends span').addClass('nonfriend');
            }
        }

        if (this.currentStumble && typeof this.currentStumble.numreviews != "undefined") {
            $('#reviews a').html(this.currentStumble.numreviews);
        }

        if (this.currentStumble && this.currentStumble.sponsored) {
            $('#sponsored').show();
        }
    },

    updateUI_User: function() {
        if (this.currentUser && this.currentUser.loggedIn) {
            $('#tb-toolbar').removeClass('tb-visitor').addClass('tb-user');
            // Update the number of notifications
            if (this.currentUser.notifications > 0){$('#tb-toolbar').addClass('tb-has-notifications');} else {$('#tb-toolbar').removeClass('tb-has-notifications');}
            $('#tb-notification .tb-btn-text').text(this.currentUser.notifications);
        }
        else {
            $('#tb-toolbar').removeClass('tb-user').addClass('tb-visitor');
        }
    },

    updateNumReferrals: function(num) {
        //nada for webtoolbar
        if (num != 0) {
            $('#numReferrals a').html('<span></span>'+num);
            $('#numReferrals').show();
        }
        else {
            $('#numReferrals').hide();
        }
    },

    handleErrorState: function(response) {
        return false;
    },

    debugText: function(text) {
       if (typeof console != "undefined") {
           console.log(text);
       }
    },

    logEvent: function(event)
    {
        // logEvent is only available in the webtb api for now
        // TODO: remove this condition when it is also in chromebar
        if (this.device == 'webtb') {
            this.api.logEvent(event);
        }
    },

    /*
     * getCurrentUrlInfo
     *
     * Gets the stumble info for the current url.  In the basic webbar this is just the currentStumble,
     * other toolbars will get the data form local storage or if it's not local then they will
     * look it up if checkServer is true.
     */
    getCurrentUrlInfo: function(callback, checkServer) {
        callback(this.currentStumble);
    },

    getShareInfo: function() {
        var instance = this;
        this.getCurrentUrlInfo(function(urlinfo) {
            var globals = instance.getGlobals();
            var value = globals.shares;
            if (value != null && value != {})
            {
                for (shareid in value)
                {
                    if (value[shareid] == urlinfo.url)
                    {
                        urlinfo.sharePid = shareid;
                        instance.setActiveStumble(urlinfo);
                        instance.markShareSeen(shareid);
                    }
                }
            }
        });
    },

    markShareSeen: function(shareid) {
        var globals = this.getGlobals();
        var value = globals.shares;
        delete value[shareid];
        this.updateGlobals({ shares: value });
        this.api.markShareSeen(shareid);
    },

    ratingCallback: function(response, extraCallback) {
        this.ratingInProgress = false;
        this.mediator.trigger("rating:completed");

        if (response._success)
        {
            if (response.new_rating == -1) {
                if (this.currentUser) {
                    this.currentUser.favorites--;
                    this.setData('userInfo', this.currentUser);
                }
            }
            else {
                //todo: remove this autoshared message crap in a bit..added in on 02/02
                if (response.rating == 1
                        && response.toolbarState
                        && response.toolbarState.globalState
                        && response.toolbarState.globalState.messageOverlay) {
                    this.displayMessageOverlay(response.toolbarState.globalState.messageOverlay);
                }
                if (this.currentUser) {
                    this.currentUser.favorites++;
                    this.setData('userInfo', this.currentUser);
                    if (response.noFacebookPublish) {
                        this.currentUser.facebookPublish = false;
                    }
                }
                else {
                    this.setData('pendingRating', {
                        publicid: this.currentStumble.publicid,
                        rating: 1
                    });
                    this.toggleLoginUI();
                }
            }

            if (response.callToAction && !this.currentStumble.forcedStumbling) {
                response.anchorElement = (1 == response.rating) ? 'tb-like' : 'tb-notlike';
                this.handleImplication(response);
            }

            this.updateUI_User();
        }
        else if (response.redirect_url) {
            // redirect to the error page
            this.gotoUrl(response.redirect_url, 'cannotrate');
        }
        else {
            this.ratingCallbackError(null, null, null);
        }

        if (extraCallback) {
            extraCallback();
        }
    },

    handleImplication: function(response) {

        var cta = response.callToAction,
            instance = this,
            overlayName = 'implication',
            message = cta.message[0],
            messageComponents = cta.message[1],
            regex;

            // @todo use stringsub handlebars render helper when it is merged.
            for (key in messageComponents) {
                regex = new RegExp("%" + key + "%", 'g');
                message = message.replace(regex, "<strong>" + messageComponents[key] + "</strong>");
            }

            text = Handlebars.templates.tbTooltip({
                tooltipName: overlayName,
                message: message,
                callToAction: [{
                    name: 'accept',
                    message: cta.message[2],
                    className: 'primary'
                }, {
                    name: 'decline',
                    message: cta.message[3]
                }]
            });

        this._implicationData = {
            id: cta.id,
            sourceId: cta.sourceId,
            targetId: cta.targetId,
            implicationCode: cta.implicationCode,
            userid: cta.userid,
            score: cta.score
        };

        var callbacks = {
            'implication-accept': {
                'implicationSubmit': 'accepted'
            },
            'implication-ignore': {
                'implicationSubmit': 'ignored'
            },
            'implication-decline': {
                'implicationSubmit': 'declined'
            }
        };

        this.overlayManager.openOverlay(overlayName, {
            type: 'permanenttooltip',
            data: text,
            refresh: true,
            anchorElement: $('#' + response.anchorElement),
            closeOthers: true,
            callbacks: callbacks,
            size: {
                'max-width': 300
            }
        });
    },

    implicationSubmit: function(decision) {
        var postData = this._implicationData,
            instance = this;

        postData.response = decision;
        postData.source = this.device;

        $.ajax({
            url: '/implication/submit',
            data: postData,
            type: 'POST'
        }).success(function() {
          instance.overlayManager.closeOverlay('implication');
        }).error(function(response) {
        });
    },

    ratingCallbackError: function (jqXHR, textStatus, errorThrown) {
        this.ratingInProgress = false;
        this.mediator.trigger("rating:completed");

        if (this.currentStumble) {
            // Rating not done on the server side
            // go back to the previous rating
            if (typeof this.currentStumble.previousRating == 'undefined') {
                delete this.currentStumble.rating;
            } else {
                this.currentStumble.rating = this.currentStumble.previousRating;
            }
        }

        var msg = this.messages.genericError.replace('%1', jqXHR.status);
        this.updateUI_User();
        this.updateUI_StumbleMeta();
        this.displayNotification({
            type: 'error',
            message: msg
        });
    },

    toggleLists: function() {
        var Modal = require("module/modal"),
            SelectListView = require("module/views/lists_select_view");

        new Modal({
            view: SelectListView,
            title: "Add to List",
            subTitle: "Start typing to search or create a List.",
            modalClass: "small",
            viewOptions: {
                viewer: this.viewer,
                urlId: this.currentStumble.publicid,
                dropdownOptions: {
                    disableHide: true,
                    immediate: true,
                    allowCreate: true,
                    itemKey: "name"
                }
            }
        });
    },

    toggleThumbDownMore: function() {
        var url = '/su/overlay/notlikemore?src='
            + this.source + '&pid='
            + encodeURIComponent(this.currentStumble.publicid);

        if (this.currentStumble.friend) {
            url += '&friendid=' + encodeURIComponent(this.currentStumble.friend.userid);
        } else if (this.currentStumble.discoverer) {
            url += '&discovererid=' + encodeURIComponent(this.currentStumble.discoverer.userid);
        }

        if (this.currentStumble.sponsored) {
            url += "&sponsored=true";
        }
        if (this.overlayManager) {
            this.overlayManager.toggleOverlay('thumbdown-menu', {
                url: url,
                type: 'floating',
                anchorElement: $('#tb-notlikemore'),
                size: {width: 220, height: this.notLikeMoreHeight},
                closeOthers: ['floating', 'notification'],
                refresh: true
            });
        }
    },

    toggleShowMeMore: function() {
        var height = 135;
        var url = '/su/overlay/showmemore?src='
            + this.source + '&pid='
            + encodeURIComponent(this.currentStumble.publicid);

        if (this.currentStumble.friend) {
            url += '&friendid=' + encodeURIComponent(this.currentStumble.friend.userid);
        } else if (this.currentStumble.discoverer) {
            url += '&discovererid=' + encodeURIComponent(this.currentStumble.discoverer.userid);
        } else {
            height = 101;
        }

        if (this.currentStumble.sponsored){url += "&sponsored=true";}
        if (this.overlayManager) {
            this.overlayManager.toggleOverlay('thumbup-menu', {
                url: url,
                type: 'floating',
                anchorElement: $('#tb-likemore'),
                size: {width: 250, height: height},
                closeOthers: ['floating', 'notification']
            });
        }
    },

    toggleUrlInfoMenu: function() {
        var url = '/su/overlay/urlinfo/?pid=' + this.currentStumble.publicid + '&src=' + this.source;
        if (this.overlayManager) {
            this.overlayManager.toggleOverlay('comment-menu', {
                url: url,
                type: 'floating',
                anchorElement: $('#tb-comment'),
                size: {width: 495, height: this.urlInfoHeight},
                closeOthers: ['floating'],
                refresh: true
            });
        }
    },

    showSharePanel: function(pid, urlToShare) {
        var refresh = (this._previousSharedPid != (pid ? pid :  urlToShare));
        this._previousSharedPid = (pid ? pid : urlToShare);
        if (pid) {
            var url = '/su/overlay/share/?pid=' + pid + '&src=' + this.source;
        } else {
            var url = '/su/overlay/share/?url=' + encodeURIComponent(urlToShare) + '&src=' + this.source;
        }
	if (this.overlayManager) {
            this.overlayManager.openOverlay('share-menu', {
                url: url,
                type: 'floating',
                anchorElement: $('#tb-share'),
                size: {width: 495, height: this.shareMenuHeight},
                closeOthers: ['floating', 'notification'],
                refresh: refresh
            });
        }
    },

    toggleInterestsPanel: function(hidden) {
        var url = '/su/overlay/interests/?src=' + this.source;
        var options = {
                url: url,
                type: 'floating',
                anchorElement: $('#tb-interests'),
                size: {width: 330, height: 520},
                closeOthers: ['floating', 'notification']
            };
        if (this.overlayManager) {
            if (hidden) {
                this.overlayManager.openOverlay('interests-menu', options, true);
            } else {
                this.overlayManager.toggleOverlay('interests-menu', options);
            }
        }
    },

    toggleSharePanel: function(pid, urlToShare) {
        var refresh = (this._previousSharedPid != (pid ? pid :  urlToShare));
        this._previousSharedPid = (pid ? pid : urlToShare);
        if (pid) {
            var url = '/su/overlay/share/?pid=' + pid + '&src=' + this.source;
        } else {
            var url = '/su/overlay/share/?url=' + encodeURIComponent(urlToShare) + '&src=' + this.source;
        }
	if (this.overlayManager) {
            this.overlayManager.toggleOverlay('share-menu', {
                url: url,
                type: 'floating',
                anchorElement: $('#tb-share'),
                size: {width: 495, height: this.shareMenuHeight},
                closeOthers: ['floating', 'notification'],
                refresh: refresh
            });
        }
    },

    toggleShareFacebookPanel: function(pid, urlToShare) {
        var refresh = (this._previousSharedPid != (pid ? pid :  urlToShare));
        this._previousSharedPid = (pid ? pid : urlToShare);
        if (pid) {
            var url = '/su/overlay/share/facebook?pid=' + pid + '&src=' + this.source;
        } else {
            var url = '/su/overlay/share/facebook?url=' + encodeURIComponent(urlToShare) + '&src=' + this.source;
        }
	if (this.overlayManager) {
            this.overlayManager.toggleOverlay('share-facebook-menu', {
                url: url,
                type: 'floating',
                anchorElement: $('#tb-share-facebook'),
                size: {width: 495, height: 238},
                closeOthers: ['floating', 'notification'],
                refresh: refresh
            });
        }
    },

    showHoverTip: function(node, delay) {
        var instance = this,
            id = node.attr('id');

        if (typeof delay === "undefined") {
            delay = 800;
        }
        // I don't display tooltips if floating overlays are displayed
        if ($('#tb-toolbar').data('overlayfloating') > 0 ||
            $('#tb-toolbar').data('overlaypermanenttooltip') > 0 ||
            (this.delayedTooltips[id] && delay) ||
            !node.data('tooltip')) {
            return;
        }

        if (delay) {
            this.delayedTooltips[id] = setTimeout(showTip, delay);
        } else {
            showTip();
        }

        function showTip() {
            // I don't display tooltips if floating overlays are displayed
            if ($('#tb-toolbar').data('overlayfloating') > 0 ||
                $('#tb-toolbar').data('overlaypermanenttooltip') > 0) {
                instance.delayedTooltips[id] = 0;
                return;
            }

            if ( instance.overlayManager ) {
                instance.overlayManager.openOverlay('tooltip-' + id, {
                    type: 'tooltip',
                    data: node.data('tooltip'),
                    anchorElement: $('#' + id),
                    closeOthers: ['tooltip', 'permanenttooltip'],
                    size: {'max-width': 250}
                });
                // Show stumble button tooltip arrow if there
                node.find("#tooltip-arrow").show();
            }
        }
    },

    hideHoverTip: function(node) {
        var id = node.attr('id');
        if (this.overlayManager) {
            this.overlayManager.closeOverlay('tooltip-' + id);
        }
        // Remove possible timer
        if (this.delayedTooltips[id]){
            clearTimeout(this.delayedTooltips[id]);
        }
        this.delayedTooltips[id] = 0;

        // Hide stumble button tooltip arrow if there
        node.find("#tooltip-arrow").hide();
    },

    bindOverlayCallbacks: function(overlay) {},

    // Listener Interface implementation to handle the overlays open/close events
    onOverlayOpened: function(overlay) {

        this.bindOverlayCallbacks(overlay);

        var tb = $('#tb-toolbar');
        tb.addClass('tb-overlay-' + overlay.id);
        var count = tb.data('overlay' + overlay.options.type);
        if (typeof count == 'undefined') {
            count = 0;
        }
        count++;
        tb.data('overlay' + overlay.options.type, count);
        if (count >= 1) {
            tb.addClass('tb-over-' + overlay.options.type);
        }

        // If we open a overlay which is not a tooltip, we should close all the tooltip overlays
        if ($.inArray(overlay.options.type, ['tooltip', 'permanenttooltip']) == -1) {
            this.overlayManager.closeOtherOverlays(null, ['tooltip', 'permanenttooltip']);
        }

        if (count == 1 && overlay.options.type == "floating" && this.currentStumble && this.currentStumble.has_bad_flash) {
            $('#tb-stumble-frame').hide();
            $('#tb-stumble-container-bad-flash').show();
        }

        if ($.inArray(overlay.options.type, ['top', 'right', 'bottom', 'left']) >= 0) {
            this.onResize();
        }
    },

    onOverlayClosed: function(overlay) {
        var tb = $('#tb-toolbar');
        var count = tb.data('overlay' + overlay.options.type);
        if (typeof count == 'undefined') {
            count = 1;
        }
        count--;
        tb.data('overlay' + overlay.options.type, count);

        if (count < 1) {
            tb.removeClass('tb-over-' + overlay.options.type);
        }

        $('#tb-toolbar').removeClass('tb-overlay-' + overlay.id);

        if (count < 1 && overlay.options.type == "floating" && this.currentStumble && this.currentStumble.has_bad_flash)
        {
            $('#tb-stumble-frame').show();
            $('#tb-stumble-container-bad-flash').hide();
        }

        if ($.inArray(overlay.options.type, ['top', 'right', 'bottom', 'left']) >= 0) {
            this.onResize();
        }
    },

    hideToolbar: function() {
        if (suExtensionApi && suExtensionApi.toolbar) {
            suExtensionApi.toolbar.closeToolbar();
        } else if (this.currentStumble) {
            this.gotoUrl(this.currentStumble.url, 'closetoolbar');
        } else {
            // TODO make this go to actual page in chromebar and other clients that can see that
            this.gotoUrl("/", 'closetoolbar');
        }
    },

    enableStumbling: function() {
        $("#tb-stumble").removeClass("disabled tip");
        this.overlayManager.destroyOverlay("tooltip-tb-stumble");
    },

    enableForceStumbling: function() {
        var self = this;

        $("#tb-stumble").addClass("disabled tip");

        $("#tb-stumble.disabled").on("mouseenter", function() {
            if (self.needsRating()){
                self.showHoverTip($(this), false);
            }
        }).on("mouseleave", function() {
            self.hideHoverTip($(this));
        });
    },

    needsRating: function() {
        if (!this.currentStumble) {
            return false;
        }

        if (!this.currentStumble.forcedStumbling) {
            return false;
        }

        return (typeof this.currentStumble.rating === 'undefined');
    },

    isLoggedIn: function() {
        var globals = this.getGlobals();
        return (globals && globals.user && globals.user.loggedIn);
    },

    isNonRateable: function(url) {
        if (!url) {
            return true;
        }

        return !!url.match(this.nonRateableRegex);
    },

    isNonShareable: function(url) {
        if (!url) {
            return true;
        }

        return !!url.match(this.nonShareableRegex);
    },

    //events handled by all litebars. assumes DOM structure
    userInterfaceEvents: {
        buttonTooltipClick: {
            target: '.tips',
            action: 'click.tips',
            handler: function(event) {
                event.data.instance.hideHoverTip($(this));
            }
        },
        buttonTooltipOn: {
            target: '.tips',
            action: 'mouseenter.tips',
            handler: function(event) {
                event.data.instance.showHoverTip($(this));
            }
        },
        buttonTooltipOff: {
            target: '.tips',
            action: 'mouseleave.tips',
            handler: function(event) {
                event.data.instance.hideHoverTip($(this));
            }
        },
        toolbarClick: {
            target: '#tb-toolbar',
            action: 'click',
            handler: function(event) {
                if ( event.data.instance.overlayManager ) {
                    event.data.instance.overlayManager.closeOtherOverlays(null, ['floating', 'notification']);
                }
            }
        },
        homeClick: {
            target: '#tb-home a',
            action: 'click',
            handler: function(event) {
                event.data.instance.gotoUrl("http://www.stumbleupon.com/home");
                return false;
            }
        },
        userLabelClick: {
            target: '#tb-userlabel a',
            action: 'click',
            handler: function(event) {
                var newTab = ($('#tb-userlabel a').attr('target')[0] == '_blank');
                event.data.instance.gotoUrl($('#tb-userlabel a ').attr('href'), newTab);
                return false;
            }
        },
        stumble: {
            target: '#tb-stumble a',
            action: 'click',
            handler: function(event) {
                var instance = event.data.instance;
                instance.logEvent('click-stumble');
                // The following is an intentional and useful debugging tool, please don't remove
                if (event.altKey && event.shiftKey) {
                    debugger;
                    return;
                }
                if (instance.needsRating()){
                    return;
                }
                instance.overlayManager.destroyOverlaysTypes('floating');
                if ( ((instance.device == 'chromebar') || (instance.device == 'safaribar')) &&
                     !instance.isLoggedIn() ) {
                    instance.displayNotification({
                        type: 'info',
                        message: instance.messages.notLoggedInNoStumble,
                        delay: 10000 // 10 seconds
                    });
                } else {
                    event.data.instance.performStumble();
                }
                return false;
            }
        },
        thumbUp: {
            target: '#tb-like a',
            action: 'click',
            handler: function(event) {
                var instance = event.data.instance;
                instance.logEvent('click-thumbup');
                instance.mediator.trigger("thumbUp");
                instance.getCurrentUrlInfo(function(urlinfo) {
                    if (urlinfo && urlinfo.known) {
                        instance.performRating(1);
                    } else if (instance.isNonRateable(urlinfo.url)) {
                        instance.displayNotification({
                            type: 'error',
                            message: instance.messages.nonRateable,
                            delay: 8000
                        });
                    } else {
                        // Send to the submit page
                        instance.gotoUrl("https://www.stumbleupon.com/submit?url="+encodeURIComponent(urlinfo.url), 'submitpage', true);
                    }
                }, true);
                return false;
            }
        },
        showMeMore: {
            target: '#tb-likemore a',
            action: 'click',
            handler: function(event) {
                var instance = event.data.instance;
                instance.logEvent('click-thumbupmenu');
                instance.getCurrentUrlInfo(function(urlinfo) {
                    if (urlinfo && urlinfo.known) {
                        instance.toggleShowMeMore();
                    } else if (instance.isNonRateable(urlinfo.url)) {
                        instance.displayNotification({
                            type: 'error',
                            message: instance.messages.nonRateable,
                            delay: 8000
                        });
                    } else {
                        instance.displayNotification({
                            type: 'info',
                            message: instance.messages.notDiscoveredNoThumbUpMore
                        });
                    }
                }, true);
                return false;
            }
        },
        thumbListsMenuToggle: {
            target: '#tb-lists a',
            action: 'click',
            handler: function(event) {
                var instance = event.data.instance;
                instance.logEvent('click-lists');
                instance.getCurrentUrlInfo(function(urlinfo) {
                    if (instance.isNonRateable(urlinfo.url)) {
                        instance.displayNotification({
                            type: 'error',
                            message: instance.messages.nonRateable,
                            delay: 8000
                        });
                    } else {
                        instance.toggleLists();
                    }
                }, true);
                return false;
            }
        },
        thumbDown: {
            target: '#tb-notlike a',
            action: 'click',
            handler: function(event) {
                var instance = event.data.instance;
                instance.logEvent('click-thumbdown');
                instance.mediator.trigger("thumbDown");
                instance.getCurrentUrlInfo(function(urlinfo) {
                    if (urlinfo && urlinfo.known) {
                        instance.performRating(0);
                    } else if (instance.isNonRateable(urlinfo.url)) {
                        instance.displayNotification({
                            type: 'error',
                            message: instance.messages.nonRateable,
                            delay: 8000
                        });
                    } else {
                        instance.displayNotification({
                            type: 'info',
                            message: instance.messages.notDiscoveredNoThumbDown
                        });
                    }
                }, true);
                return false;
            }
        },
        thumbDownMoreToggle: {
            target: '#tb-notlikemore a',
            action: 'click',
            handler: function(event) {
                var instance = event.data.instance;
                instance.logEvent('click-thumbdownmenu');
                instance.getCurrentUrlInfo(function(urlinfo) {
                    if (urlinfo && urlinfo.known) {
                        instance.toggleThumbDownMore();
                    } else if (instance.isNonRateable(urlinfo.url)) {
                        instance.displayNotification({
                            type: 'error',
                            message: instance.messages.nonRateable,
                            delay: 8000
                        });
                    } else {
                        instance.displayNotification({
                            type: 'info',
                            message: instance.messages.notDiscoveredNoThumbDown
                        });
                    }
                }, true);
                return false;
            }
        },
        shareFacebookMenuToggle: {
            target: '#tb-share-facebook a',
            action: 'click',
            handler: function(event) {
                var instance = event.data.instance;
                instance.logEvent('click-facebook');
                instance.getCurrentUrlInfo(function(urlinfo) {
                    if( urlinfo && urlinfo.known && urlinfo.publicid) {
                        instance.toggleShareFacebookPanel(urlinfo.publicid);
                    } else if (instance.isNonShareable(urlinfo.url)) {
                        instance.displayNotification({
                            type: 'error',
                            message: instance.messages.nonShareable,
                            delay: 8000
                        });
                    } else {
                        instance.toggleShareFacebookPanel(null, urlinfo.url);
                    }
                }, true);
                instance.trk('normalShareFacebookClick');
                return false;
            }
        },
        shareMenuToggle: {
            target: '#tb-share a',
            action: 'click',
            handler: function(event) {
                var instance = event.data.instance;
                instance.logEvent('click-share');
                instance.getCurrentUrlInfo(function(urlinfo) {
                    if( urlinfo && urlinfo.known && urlinfo.publicid) {
                        instance.toggleSharePanel(urlinfo.publicid);
                    } else if (instance.isNonShareable(urlinfo.url)) {
                        instance.displayNotification({
                            type: 'error',
                            message: instance.messages.nonShareable,
                            delay: 8000
                        });
                    } else {
                        instance.toggleSharePanel(null, urlinfo.url);
                    }
                }, true);
                instance.trk('normalShareClick');
                return false;
            }
        },
        interestsMenuToggle: {
            target: '#tb-interests a',
            action: 'click',
            handler: function(event) {
                event.data.instance.logEvent('click-interestsmenu');
                event.data.instance.toggleInterestsPanel();
                return false;
            }
        },
        topicDeselection: {
            target: '#topics.cancel .bgImgRight',
            action: 'click',
            handler: function(event) {
                if ($('#topics').hasClass('cancel')) {
                    event.data.instance.resetStumblingMode();
                    // TODO take out reference to chromebar here. quick fix
                    if (event.data.instance.device == 'chromebar') {
                        suExtensionApi.message.broadcastMessage('localUpdateStumblingTopic', { id: 0, name: 'All Interests'});
                    }
                    if (typeof event.data.instance.hideViewPane != "undefined") {
                        event.data.instance.hideViewPane(event.data.instance.viewPanes['topics']);
                    }
                    event.data.instance.performStumble();
                }
                else {
                    event.data.instance.toggleTopicSelectorUI();
                }
                return false;
            }
        },
        showUrlInfo: {
            target: '#tb-comment a',
            action: 'click',
            handler: function(event) {
                var instance = event.data.instance;
                instance.logEvent('click-urlinfo');
                instance.getCurrentUrlInfo(function(urlinfo) {
                    if (urlinfo && urlinfo.known) {
                        instance.toggleUrlInfoMenu();
                    } else {
                        instance.displayNotification({
                            type: 'info',
                            message: instance.messages.notDiscoveredNoUrlInfo
                        });
                    }
                }, true);
                return false;
            }
        },

        /*
        showUserInfo: {
            target: '#tb-userlabel a',
            action: 'click',
            handler: function(event) {
                if (!event.data.instance.currentStumble.friend && !event.data.instance.currentStumble.discoverer)
                    return;

                var instance = event.data.instance;

                var url = '/su/overlay/userinfo/?pid=' + instance.currentStumble.publicid + '&src=' + instance.source;
                if (instance.currentStumble.friend)
                    url += '&friendid=' + encodeURIComponent(instance.currentStumble.friend.userid);
                else
                    url += '&discovererid=' + encodeURIComponent(instance.currentStumble.discoverer.userid);
                instance.overlayManager.toggleOverlay('userinfo-menu', {
                    url: url,
                    type: 'floating',
                    anchorElement: $('#tb-userlabel'),
                    size: {width: 300, height: 110},
                    closeOthers: ['floating'],
                    refresh: true
                });
                return false;
            }
        },
        */

        notificationMenuToggle: {
            target: '#tb-notification a',
            action: 'click',
            handler: function(event) {
                var instance = event.data.instance;
                instance.logEvent('click-notification');
                var height = 101;
                if (event.data.instance.currentUser && instance.currentUser.notifications){height = 135 + instance.currentUser.notifications * 56;}
                if (height > 300){height = 300;}
                var url = '/su/overlay/notification/?src=' + instance.source;
                if ( instance.overlayManager ) {
                    instance.overlayManager.toggleOverlay('notification-menu', {
                        url: url,
                        type: 'floating',
                        anchorElement: $('#tb-notification'),
                        anchorToRight: true,
                        size: {width: instance.notificationMenuWidth, height: height},
                        closeOthers: ['floating', 'notification'],
                        refresh: true
                    });
                }
                return false;
            }
        },
        settingsMenuToggle: {
            target: '#tb-settings a',
            action: 'click',
            handler: function(event) {
                event.data.instance.logEvent('click-settings');
                var url = '/su/overlay/settings/?src=' + event.data.instance.source;
                var height = 201;
                // first case catches when we are not stumbling and second case catches when we are stumbling an SU page
                if((window.location.href.indexOf(event.data.instance._globals.server_http + '/su/') !== 0)
                    || (
                        event.data.instance.currentStumble
                        && event.data.instance.currentStumble.url
                        && event.data.instance.currentStumble.url.indexOf(event.data.instance._globals.server_http) === 0
                       )
                   ) {
                        url += "&hideHideLink=1";
                        height = 167;
                    }
                if ( event.data.instance.overlayManager ) {
                    event.data.instance.overlayManager.toggleOverlay('settings-menu', {
                        url: url,
                        type: 'floating',
                        anchorElement: $('#tb-settings'),
                        anchorToRight: true,
                        size: {width: 140, height: height},
                        closeOthers: ['floating', 'notification']
                    });
                }
                return false;
            }
        },

        loginMenuToggle: {
            target: '#tb-login a',
            action: 'click',
            handler: function(event) {
                var instance = event.data.instance;
                event.data.instance.logEvent('click-login');
                try {
                    instance.gotoUrl(instance.loginUrl);
                } catch (err) {
                    instance.gotoUrl(instance.loginUrl);
                }

                /*
                var url = '/su/overlay/login?src=' + event.data.instance.source;
                event.data.instance.overlayManager.toggleOverlay('login-menu', {
                    url: url,
                    type: 'floating',
                    anchorElement: $('#tb-login'),
                    anchorToRight: true,
                    size: {width: 400, height: 300},
                    closeOthers: ['floating', 'notification'],
                    refresh: true
                });
                */
                return false;
            }
        },

        learnMoreMenuToggle: {
            target: '#tb-learnmore a',
            action: 'click',
            handler: function(event) {
                event.data.instance.logEvent('click-learnmore');
                event.data.instance.gotoUrl("http://www.stumbleupon.com/?pre=wtb_learnmore", 'learnmore');
                return false;
            }
        },

        signupMenuToggle: {
            target: '#tb-signup a',
            action: 'click',
            handler: function(event) {
                event.data.instance.logEvent('click-signup');
                event.data.instance.gotoUrl("https://www.stumbleupon.com/signup?pre=wtb_signup", 'signup');
                return false;
            }
        },

        sponsoredPage: {
            target: '#sponsored',
            action: 'click',
            handler: function(event) {
        //        event.data.instance.gotoUrl('/sponsored_page/');
        //        return false;
            }
        },
        favoritesLoggedOut: {
            target: '#favorites_l',
            action: 'click',
            handler: function(event) {
                event.data.instance.gotoUrl("https://www.stumbleupon.com/signup?pre=wtb_savefavs", 'signup');
                return false;
            }
        },
        favoritesLoggedOutVideo: {
            target: '#favorites_l_video',
            action: 'click',
            handler: function(event) {
                event.data.instance.gotoUrl("https://www.stumbleupon.com/signup?pre=video_wtb_savefavs", 'signup');
                return false;
            }
        },
        favoritesLoggedIn: {
            target: '#favorites',
            action: 'click',
            handler: function(event) {
                event.data.instance.gotoUrl('/favorites/', 'favorites');
                return false;
            }
        },
        homeButton: {
            target: '#goHome',
            action: 'click',
            handler: function(event) {
                event.data.instance.logEvent('click-home');
                event.data.instance.gotoUrl("http://www.stumbleupon.com/", 'home');
                return false;
            }
        },
        closeButton: {
            target: '#tb-close a',
            action: 'click',
            handler: function(event) {
                event.data.instance.logEvent('click-close');
                event.data.instance.hideToolbar();
                return false;
            }
        }
    }
}

var SU_Timers = function() {
    this.pid      = null;
    this.uid      = null;
    this.data     = [];
    this.dataHash = {};
    this.enabled  = ("localStorage" in window && window['localStorage'] !== null);
    // Try to save data into localStorage
    // Because it crashes on private mode (safari at least)
    try {
        window.localStorage.setItem('test_localStorage', new Date().getTime());
    }
    catch (err) { this.enabled = false; }

    this.hasInterruption = false;

    this.noDuplicates = {
        stumbleRequest : 1,
        stumbleResponse: 1,
        interrupted    : 1 };

    this.interruptedEntries = {
        'nextStumbleClick'        : 1,
        'interrupted'          : 1,
        'interrupted-closetoolbar': 1,
        'interrupted-home'      : 1,
        'interrupted-login'      : 1,
        'interrupted-reviews'      : 1,
        'interrupted-shares'      : 1,
        'interrupted-signup'      : 1
        //'interrupted-stumbler'      : 1,
        };

        return true;
}

SU_Timers.prototype = {
    init: function(urlid) {
        // Check if we have a global var defined at the beginning of the template
        // include/smarty/templates/master/master_litebar_su.tpl
        var v = new Date().getTime();

        if ("_stumbleResponse" in window && !isNaN(window._stumbleResponse) && window._stumbleResponse > 0) {
            v = window._stumbleResponse;
        }

        this.addEvent('stumbleResponse', v);
        this.addEvent('startLoad');
    },

    reset: function() {
        if (!this.enabled) {
            return false;
        }

        this.pid      = null;
        this.data     = [];
        this.dataHash = {};

        return true;
    },

    setPidAndUid: function(_pid, _uid) {
        if (!this.enabled) {
            return;
        }

        this.pid = _pid;
        this.uid = _uid;
    },

    addEvent: function(eventName, time) {

        if (!this.enabled) {
            return;
        }

        if (!time) {
            time = new Date().getTime();
        }

        if (eventName in this.noDuplicates && this.hasEvent(eventName)) {
            return;
        }

        if (eventName in this.interruptedEntries)
        {
            if (this.hasInterruption) {
                return;
            }
            this.hasInterruption = true;
        }

        if (eventName == 'stumbleRequest') {
            // We want this event to be first
            this.data.unshift( {"event": eventName, "timestamp": time } );
        } else {
            this.data.push( {"event": eventName, "timestamp": time } );
        }

        this.dataHash[eventName] = time;
    },

    hasEvents: function() {
        return this.data.length > 0;
    },

    hasEvent: function(eventName) {
        if (!this.enabled || (typeof this.dataHash[eventName] == 'undefined')) {
            return false;
        }
        return true;
    },

    saveTimersToDOMStorage: function() {
        if (!this.enabled || !this.pid || !this.uid || this.hasEvents() == 0) {
            return false;
        }

        try {
            window.localStorage.setItem('saved_data', JSON.stringify(this));
            window.localStorage.setItem('saved_pid', this.pid);
            window.localStorage.setItem('saved_uid', this.uid);
        } catch (err) {}

        return true;
    },

    /**
     * return an object:
     * { pid: pid, uid: uid, data: data values }
     **/
    getSavedTimers: function() {
        if (!this.enabled) {
            return null;
        }

        var saved_pid = window.localStorage.getItem('saved_pid');
        var saved_uid = window.localStorage.getItem('saved_uid');
        var saved_data = window.localStorage.getItem('saved_data');
        if (!saved_pid || !saved_data) {
            return null;
        }

        window.localStorage.removeItem('saved_pid');
        window.localStorage.removeItem('saved_uid');
        window.localStorage.removeItem('saved_data');
        return { pid: saved_pid, uid: saved_uid, data: saved_data };
    }
};/**
 * Chromebar Client Implementation
 *   - inherits from Litebar client impl class
 */
var SU_ClientChromebar = function() {
    this.device                = 'chromebar';
    this.source                = 'litebar';
    this.consumerKeyDev        = '947000d7075c4f1c4df6c7560cc0e100b3030cd0';
    this.consumerKeyPrd        = '490dc4a8a16bfe4d5c99530ab1fccdd05eb8ad16';
    this.consumerKey           = '';
    this.load_globals_attempts = 0;
}
SU_ClientChromebar.prototype  = new SU_ClientLitebar();
SU_ClientChromebar.superclass = SU_ClientLitebar.prototype;

var SU_ClientChromebar_prototype = {
    // Note:  This is re-entered during different async initialization phases
    init: function(pageGlobals) {
        var instance = this;

        if(pageGlobals)
            this.pageGlobals = pageGlobals;

        // Chromebar needs the extension api
        if(!this.waitForExtensionApi())
            return;

        if(!this.waitForConsumerKey())
            return;

        // Get the target domain
        suExtensionApi.getDomain(function(domain) {
            instance.domain = domain;
        });


        // Get our globals from the extension data store
        suExtensionApi.data.getValue("globals", function(globals) {
            if (globals) {
                instance.updateAllGlobals(globals, true);
                instance.init2();
            } else {
                instance.updateAllGlobals(instance.pageGlobals, false);
                instance.init2();
            }
        });
    },

    /*
     * Second-stage initialization, called after we've retrieved our globals
     */
    init2: function() {
        var instance = this;
        suExtensionApi.message.addListener(function(messageId, data, sender) {
            instance.onExtApiMessage(messageId, data, sender);
        });

        // Initialize the litebar
        SU_ClientChromebar.superclass.init.call(this, this.getGlobals(), null);

        var globals = instance.getGlobals();
        // if the oauth token isn't set, see if we can get a new one
        if (!globals.oAuth)
        {
            // After getting the oauth token, get our current state
            this.getOAuthToken(function() {
                instance.getState(function() {});
            });
        }
        else
            this.getState(function() {});
    },

    getVersionInfo: function () {
        var versioninfo = suExtensionApi._info._providerVersion.split('.');
        return {
            major:       parseInt(versioninfo[0]),
            minor:       parseInt(versioninfo[1]),
            maintenance: parseInt(versioninfo[2]),
            build:       parseInt(versioninfo[3])
        };
    },

    versionCompare: function(ver1, ver2) {
        var parts1 = ver1.split(".");
        var parts2 = ver2.split(".");
        for(var i=0; i<parts1.length; i++) parts1[i] = parseInt(parts1[i]);
        for(i=0; i<parts2.length; i++) parts2[i] = parseInt(parts2[i]);

        for(i=0; i<parts1.length; i++) {
            if(parts1[i] && !parts2[i])
                return 1;
            if(parts1[i] != parts2[i])
                return parts1[i] - parts2[i];
        }

        // At this point all parts of v1 are matched in v2.
        // If v2 has any more parts, then v2 is greater, otherwise
        // they are equal
        if(parts2.length > parts1.length)
            return -1;
        return 0;
    },

    getOAuthToken: function(callback) {
        var instance = this;
        // Only do this if we are using an oauth-supporting version of chromebar
        var version = suExtensionApi._info._providerVersion;
        if (this.versionCompare(version, "4.3.14") >= 0)
        {
            suExtensionApi.litebar.getBrowserLocation(function(url) {
                // Only try to get the token if we are on a site page
                if (url.indexOf('stumbleupon.com') != -1 || url.indexOf('stumble.net') != -1)
                {
                    instance.api.getOAuthToken(callback);
                }
                else if (callback)
                    callback();
            });
        }
    },

    clearOAuthToken: function(callback) {
        this.updateGlobals({
            oAuth: null
        });
        if (callback != undefined)
            callback();
    },

    /*
     * getCurrentUrlInfo
     *
     * Overriden to get the url info locally (and update the active stumble when it is found)
     */
    getCurrentUrlInfo: function(callback, checkServer) {
        var self = this;

        // Get the current url
        suExtensionApi.litebar.getContentLocation(function(url) {
            // For some unsupported page types (e.g. reproduced with file:///suggest-interests?runout=2), webkit
            // will give us an undefined or empty url
            if (!url) {
                self.setActiveStumble(null);
                if (callback)
                    callback({ url: "about:blank" });
                return;
            }

            // Check whether we have local data about the url
            self.getLocalUrlInfo(url, function(urlinfo) {
                if (urlinfo && urlinfo.known) {
                    // We have local info, we are done!
                    self.setActiveStumble(urlinfo);
                    if (callback)
                        callback(urlinfo);
                    return;
                }

                // If they don't want to check the server then we're done
                if (!checkServer) {
                    // We don't have additional stumble info, just the url
                    self.setActiveStumble(null);
                    if (callback)
                        callback({ url: url });
                    return;
                }

                // They're okay with checking the server, so do it.
                self.performUrlLookup(url, function(remoteInfo) {
                    // Merge the local and remote information
                    var newInfo = jQuery.extend({}, urlinfo, remoteInfo);

                    // The server returns the canonical url, but we also need the original url so we can
                    // find data about it
                    if (newInfo) {
                        newInfo.canonicalUrl = newInfo.url;
                        newInfo.url = url;
                    }

                    // Notify the background page of the new URL data
                    if (newInfo && newInfo.known)
                        suExtensionApi.message.broadcastMessage("msgUpdateUrlData", newInfo);

                    // Update the active stumble and call the callback
                    self.setActiveStumble(newInfo);
                    if (callback) {
                        // Make sure we at least provide the url
                        if (!newInfo)
                            newInfo = { url: url };
                        callback(newInfo);
                    }
                });
            });
        });
    },

    updateCurrentUrlInfo: function() {
        // Just get the current url info, which will update the "currentStumble" data.
        // But do so without hitting the server
        this.getCurrentUrlInfo();
    },

    performUrlLookup: function(url, callback) {
        this.api.getUrlInfo(url, function(info) {
            var result = { url: url, known: false };
            if(info.success && info.urlinfo.known) {
                result = info.urlinfo;
            }
            if(callback)
                callback(result);
        });
    },

    // Retrieve url info from local storage.  This is the normal path for
    // a stumbled url -- the stumble data is stored locally, then the page is navigated,
    // then the data is retrieved with this function.
    getLocalUrlInfo: function(url, fnCallback) {
        // If we have stumble data, then show this as a stumble
        var urlData = this.getStumbleData(url);
        fnCallback(urlData);
    },

    isMatchingUrl: function(url, urlData) {
        // Strip trailing / from both (we consider them matching regardless of trailing slash)
        var url2 = urlData.url;
        url2 = url2.replace(/\/$/, '');
        url = url.replace(/\/$/, '');

        var globals = this.getGlobals();
        var videoTest = globals.server_http + "/su/video/" + urlData.publicid;
        var photoTest = globals.server_http + "/su/image/" + urlData.publicid;

        return ( (url == url2) || (url == videoTest) || (url == photoTest) );
    },

    getStumbleData: function(url) {
        if (!url)
            return null;

        // See if we have any urls stored in the local user data
        var globals = this.getGlobals();
        if(!globals || !globals.localUserData || !globals.localUserData.urls)
            return null;

        var urls = globals.localUserData.urls;
        if (urls.length) {
            // The old storage format is an array
            for (var i=0; i<urls.length; i++) {
                if (this.isMatchingUrl(url, urls[i]))
                    return urls[i];
            }
            return null;
        } else {
            // The new storage format is a dictionary, but the video/photo hack requires us to
            // traverse the dictionary
            for (var urlKey in urls) {
                if (this.isMatchingUrl(url, urls[urlKey]))
                    return urls[urlKey];
            }
            return null;
        }
    },

    /*
     * Look locally for the PID for a URL.  It can either come from local stumble data
     * that we have because this URL was a stumble, or we can parse it from the URL in the
     * case of a video URL.
     */
    getPidForUrl: function(url) {
        var regex = new RegExp("^https?:\\/\\/" + this.domain.replace(/\./g, "\\.") + "\\/su\\/video\\/([a-zA-Z0-9]{6})$"),
            match,
            urlData;
        match = url.match(regex);
        if (match)
            return match[1];

        urlData = this.getStumbleData(url);
        if (urlData && urlData.publicid)
            return urlData.publicid;
        return null;
    },

    isOurUrl: function(url) {
        var regex = new RegExp("^https?:\\/\\/" + this.domain.replace(/\./g, "\\.") + "\\/");
        return url.match(regex);
    },

    getFullUrl: function(url) {
        if (url[0] == '/' && this.domain) {
            // We use HTTPS for all chromebar requests to our site because chromebar uses
            // access tokens in requests
            url = 'https://' + this.domain + url;
        }
        return url;
    },

    // throwing in a dummy second param as the webtoolbar has a second param for this method. :(
    gotoUrl: function(url, dummy, newTab) {
        this.overlayManager.destroyAllOverlays();
        url = this.getFullUrl(url);

        // If we are navigating to a stumbleupon.com URL, then make sure we hit the startSession API first
        if (this.isOurUrl(url)) {
            url = this.api.getStartSessionUrl(url);
            url = this.getFullUrl(url);
        }

        if (newTab)
            suExtensionApi.litebar.openTab(url);
        else
            suExtensionApi.litebar.setContentLocation(url);
    },

    onDataChanged: function(key, oldValue, newValue) {
        if(key == 'globals') {
            // updateAll will take care of refreshing the UI.  Pass true to indicate that it was
            // an external notification so it doesn't re-broadcast the change
            this.updateAllGlobals(newValue, true);
        }
    },

    onGlobalsUpdated: function(fromExternal) {
        if(!fromExternal) {
            // Notify other toolbars of the new state
            suExtensionApi.data.setValue('globals', this.getGlobals());
        }
        SU_ClientChromebar.superclass.onGlobalsUpdated.call(this, fromExternal);

        // Update the current url info in case we got some new data
        this.updateCurrentUrlInfo();
    },

    updateUrlData: function(urlData) {
        suExtensionApi.message.broadcastMessage("msgUpdateUrlData", urlData);
    },

    onExtApiMessage: function(messageId, data, sender) {
        switch(messageId) {
            case "dataChanged":
                this.onDataChanged(data.key, data.oldValue, data.newValue);
                break;
        }
    },

    waitForConsumerKey: function() {
        if (this.consumerKey)
            return true;

        var instance = this;
        suExtensionApi.litebar.getOAuthInfo(function(authInfo) {
            // Temporary workaround for old versions of chromebar that don't provide the consumer key
            // unless there is a login key.  It should _always_ provide the autyInfo with the consumer key
            // TODO:  When everyone has been upgraded past 4.5.7.1 this can be removed
            if (!authInfo) {
                if (document.location.href.indexOf('stumbleupon.com') == -1)
                    instance.consumerKey = instance.consumerKeyDev;
                else
                    instance.consumerKey = instance.consumerKeyPrd;
            } else {
                instance.consumerKey = authInfo.consumer_key;
            }
            instance.init();
        });
        return false;
    },

    toggleLists: function() {
        var self = this;
        suExtensionApi.litebar.getContentLocation(function(url) {
            var overlayUrl,
                publicid;
            if (!url) {
                self.displayNotification({
                    type: 'error',
                    message: 'Unsupported URL',
                    delay: 8000
                });
                return;
            }
            publicid = self.getPidForUrl(url);
            if (publicid) {
                overlayUrl = '/su/overlay/litebar-lists/?pid=' + publicid;
            } else {
                overlayUrl = '/su/overlay/litebar-lists/?url=' + encodeURIComponent(url);
            }
            self.overlayManager.toggleOverlay('lists', {
                url: overlayUrl,
                type: 'floating',
                anchorElement: $('#tb-lists'),
                size: { width: 250, height: 200 },
                closeOthers: ['floating', 'notification'],
                refresh: true
            });
        });
    },

    waitForExtensionApi: function() {
        // Check whether the extension API is ready.  Includes verifying that it is the api that has
        // litebar support because webbar has its own SuExtensionApiWebTb.
        var instance = this;
        if ((typeof(suExtensionApi) != 'undefined') && suExtensionApi.isReady() && suExtensionApi.litebar)
            return true;

        window.addEventListener('suScriptReadyExtensionApi', function() {
            instance.init();
        }, false);
        return false;
    },

    // @TODO:  No one is even using getData, so why do we have these data functions???
    setData: function(key, data, callback) {
        this.data[key] = data;
        if (callback) {
            callback();
        }
    },

    getData: function(key, callback) {
        if (typeof this.data[key] != "undefined") {
            callback(this.data[key]);
        }
        else {
            throw "Invalid data identifier";
        }
    },

    preloadNextStumble: function(guess) {
        // There isn't an urgency here, so do this slightly later
        window.setTimeout(function() {
            var link;
            if (suExtensionApi.litebar.prerender) {
                suExtensionApi.litebar.prerender(guess.url);
            }  else {
                link = document.createElement("link");
                link.setAttribute("href", guess.url);
                link.setAttribute("rel", "prerender");
                $('head').append(link);
            }
        }, 200);
    }
}

//prototype the prototype. do it this way because it's easier on the eyes and supporter brain
for (var func in SU_ClientChromebar_prototype) {
    SU_ClientChromebar.prototype[func] = SU_ClientChromebar_prototype[func];
}/**
 * toolbar_init.js
 *
 * js for toolbar init
 *
 * @author fabrice
 */
(function() {
    /**
     * @param strClass:
     *            class name
     * @param optionals:
     *            constructor arguments
     */
    SU.ReflectUtil = {
        newInstance : function(strClass) {
            var args = Array.prototype.slice.call(arguments, 1);
            var clsClass = eval(strClass);
            function F() {
                return clsClass.apply(this, args);
            }
            F.prototype = clsClass.prototype;
            return new F();
        }
    };

    SU.addInit("mToolbar", function(data) {
        try {
            var User = require("module/models/user");

            data.config.globalState.viewer = new User(data.viewer, {
                parse: true
            });
        } catch(e) { }

        try {
            var Modal = require("module/modal"),
                FacebookSignupView = require("module/views/facebook_signup_view");

            if (data.visitor.messages.facebookConnect) {
                setTimeout(function() {
                    new Modal({
                        title: " ",
                        skipLoader: true,
                        animate: true,
                        modalClass: "large fb-connect-welcome",
                        unclosable: true,
                        view: FacebookSignupView,
                        viewOptions: {
                            model: data.config.globalState.viewer,
                            message: data.visitor.messages.facebookConnect
                        }
                    });
                }, 500);
            }
        } catch (e) {}

        SU.WebToolbar = SU.ReflectUtil.newInstance(data.config.globalState.toolbarClass);
        SU.WebToolbar.init(data.config.globalState, data.config.stumbleInfo);
    });
}).call(this);/**
 *
 * @param listener: object that should implement onOverlayOpened(overlay) and onOverlayClosed(overlay) methods to listen to open/close events
 * @param suExtensionApi
 * @returns
 */
var suOverlayManager = function(listener, versionString) {
    var self = this;

    this.listener = listener;
    this.versionString = versionString || '';
    this.suExtensionApi = suExtensionApi;
    this._overlays = {};
    this._overlaysTypes = {
        floating: {},
        tooltip: {},
        permanenttooltip: {},
        top: {},
        notification: {}
    };
    // @todo:  Two things:  1. Re-define getProviderInfo to be synchronous, the async implementation is not needed
    //                      2. Implement the webbar specific overlays _inside_ the extension API so this special-case
    //                         isn't really needed (i.e. create / destroy the div within the api, simplifying the manager).
    this.useExtensionApi = (suExtensionApi && suExtensionApi.overlay && (suExtensionApi._info.provider === "chromebar"));

    if (!this.useExtensionApi) {
        this._disabledStumbleDiv = $('#tb-stumble-disable');
        if (this._disabledStumbleDiv.length === 0) {
            $body.append('<div id="tb-stumble-disable"></div>');
            this._disabledStumbleDiv = $('#tb-stumble-disable');
        }

        this._disabledStumbleDiv.click(function() {
            self.closeOtherOverlays(null, ['floating']);
            self._disabledStumbleDiv.hide();
        });
    }

    this.spaces = {top: 0, right: 0, bottom: 0, left: 0};

    return true;
};

suOverlay = function(listener, id, options, versionString) {
    var options2;

    this.listener = listener;
    this.id = id;
    this.visible = false;
    this.options = options;
    this.versionString = versionString || '';

    // @todo:  Two things:  1. Re-define getProviderInfo to be synchronous, the async implementation is not needed
    //                      2. Implement the webbar specific overlays _inside_ the extension API so this special-case
    //                         isn't really needed (i.e. create / destroy the div within the api, simplifying the manager).
    this.useExtensionApi = (suExtensionApi && suExtensionApi.overlay && (suExtensionApi._info.provider === "chromebar"));
    this.options.containerClass = 'tb-overlay tb-overlay-' + this.options.type;
    if (this.options.type === 'notification') {
        this.options.containerClass += ' tb-overlay-notification-type-' + this.options.notificationType;
    }
    this.options.containerId = 'tb-overlay-container-' + id;

    if(!this.useExtensionApi) {
        this.container = $('<div class="' + this.options.containerClass + '" id="' + this.options.containerId + '"></div>');
        this.container.hide();

        if (options.size.width) {
            this.container.css('width', options.size.width+'px');
        } else if (options.size['max-width']) {
            this.container.css('max-width', options.size['max-width']+'px');
        }

        if (options.size.height) {
            this.container.css('height', options.size.height+'px');
        }

        if (this.options.url) {
            this._createIframe();
        } else if (this.options.data) {
            this.container.html(this.options.data);
        } else if (options.context) {
            this.renderTemplate(options.context);
        }

        $('body').append(this.container);

        this.autoPosition($(window).width());
    }
    else {
        options2 = this._getExtApiOptions();
        if (options2.size && options2.size['max-width']) {
            // Set an initial position that is wide enough to accomodate
            // the entire element, it will recompute its size later
            options2.position = {
                width: options2.size['max-width'] + 200
            };
        }
        suExtensionApi.overlay.create(id, options2);

        this.autoPosition($(window).width());
    }
};

suOverlay.prototype = {
    _destroyIframe: function() {
        this.iframe.remove();
        delete this.iframe;
    },

    _createIframe: function() {
        // Note:  Not called when using the extension api
        if (this.iframe) {
            this._destroyIframe();
        }

        this.iframe = $('<iframe frameborder="0" class="tb-overlay-iframe" id="tb-overlay-iframe-' + this.id + '"></iframe>');
        this.iframe.attr('src', this.options.url)
                   .css({'width'     :'100%',
                         'height'    :'100%',
                         'border'    :'none',
                         'overflow'  :'auto',
                         'background':'transparent url(https://nb9-stumbleupon.netdna-ssl.com/anAVjBrzYFAmwazVAqaA_A) no-repeat center'});
        this.container.append(this.iframe);
    },

    _getFullPath: function(url) {
        // Turn relative paths into full paths
        if (url && url.indexOf("/") === 0) {
            var regex = /(^https?:\/\/[^\/]*?)\//;
            var match = document.body.baseURI.match(regex);
            var origin = match[1];
            url = origin + url;
        }

        return url;
    },

    _getExtApiOptions: function() {
        // Convert this overlay's options into extapi-compatible options
        var options2 = {},
            key;

        for (key in this.options) {
            options2[key] = this.options[key];
        }

        if (options2.anchorElement) {
            delete options2.anchorElement;
        }
        // Don't use display:none because we sometimes do asynchronous position calculations and we need it to have
        // dimensions for that to work
        options2.css = this.visible ? { visibility:'visible' } : { visibility:'hidden' };
        options2.css["box-shadow"] = "2px 6px 6px rgba(0,0,0,0.2), -2px 6px 6px rgba(0,0,0,0.2)";
        options2.css["background-color"] = "#f1f1ee";

        // Use the full path
        if (options2.url) {
            options2.url = this._getFullPath(options2.url);
        }

        // Use the simple page for simple data urls
        if (options2.data && !options2.url){
            options2.url = this._getFullPath("/su/overlay/simple?v=" + this.versionString);
        }

        return options2;
    },

    renderTemplate: function(context) {
        var template = Handlebars.templates[context.templateName];

        this.container.html(template(context.templateData));
    },

    show: function() {
        if (this.visible) {
            return;
        }
        this.visible = true;
        if (!this.useExtensionApi) {
            this.container.show();
        } else {
            suExtensionApi.overlay.update(this.id,  this._getExtApiOptions());
        }

        if (this.listener && this.listener.onOverlayOpened) {
            this.listener.onOverlayOpened(this);
        }
    },

    hide: function() {
        if (!this.visible) {
            return;
        }
        this.visible = false;

        if (!this.useExtensionApi) {
            this.container.hide();
        } else {
            suExtensionApi.overlay.update(this.id,  this._getExtApiOptions());
        }

        if (this.listener && this.listener.onOverlayClosed) {
            this.listener.onOverlayClosed(this);
        }
    },

    remove: function() {
        if (!this.useExtensionApi) {
            if (this.iframe) {
                this.iframe.remove();
            }
            this.container.remove();
        } else {
            suExtensionApi.overlay.destroy(this.id);
        }
    },

    resizeIframe: function() {
        var $iframeBody,
            newHeight,
            maxHeight,
            config = {
                "share-panel": {
                    maxHeight: 100
                }
            };

        if (this.frameLoaded) {
            $iframeBody = $(this.iframe.get(0).contentWindow.document).find("body");

            newHeight = $iframeBody.outerHeight(true);
            if (config[this.id]) {
                maxHeight = config[this.id].maxHeight;
                newHeight = newHeight > maxHeight ? maxHeight : newHeight;
            }

            this.iframe.css({
                height: newHeight
            });
            this.options.size.height = newHeight;
        }
    },

    setPosition: function(top, left, width, height) {
        var css = {},
            pos;

        if (!this.useExtensionApi) {
            if (typeof width != 'undefined') {
                css.width = width + 'px';
            } else if (this.options.size.width) {
                css.width = this.options.size.width + 'px';
            }

            if (typeof height != 'undefined') {
                css.height = height + 'px';
            } else if (this.options.size.height) {
                css.height = this.options.size.height + 'px';
            }

            css.top = top + 'px';
            css.left = left + 'px';
            this.container.css(css);
        } else {
            pos = {
                left: left,
                top: top,
                height: this.options.size.height,
                width: this.options.size.width
            };

            if (typeof width != 'undefined') {
                pos.width = width;
            }

            if (typeof height != 'undefined') {
                pos.height = height;
            }

            if (!this.options) {
                this.options = {};
            }
            this.options.position = pos;
            suExtensionApi.overlay.update(this.id,  this._getExtApiOptions());
        }
    },

    autoPosition: function(winWidth) {
        var self = this,
            winHeight,
            tbHeight,
            right,
            pos,
            tb,
            w;

        if (this.options.type == 'notification') {
            if (this.container) {
                w = this.container.width();
            } else {
                w = this.options.size.width;
            }
            pos = {
                top: 0,
                left: (winWidth - w) / 2
            };
        } else if (this.options.anchorToRight) {
            pos = this.options.anchorElement.offset();
            pos.top = this.options.anchorElement.height();
            pos.left = pos.left + this.options.anchorElement.width() - this.options.size.width;

            if (pos.left < 0) {
                pos.left = 0;
            }
        } else if (this.options.anchorElement) {
            pos = this.options.anchorElement.offset();
            if (!this.options.size.width && this.options.size['max-width']) {
                if (this.container) {
                    this.options.size.width = this.container.outerWidth();
                }
            }

            if (this.options.size.width) {
                right = pos.left + this.options.size.width;
                if (right > winWidth) {
                    pos.left = winWidth - this.options.size.width;
                    if (pos.left < 0) {
                        pos.left = 0;
                    }
                }
            }
            if (this.options.anchorElement.is('input')) {
                pos.top = this.options.anchorElement.outerHeight();
            } else {
                pos.top = this.options.anchorElement.height();
            }
        } else {
            tb = $('#tb-toolbar');
            tbHeight = tb.height();
            winHeight = $(window).height();
            if (this.useExtensionApi && this.options.type != 'top') {
                suExtensionApi.litebar.getWindowDimensions(function (response) {
                    winHeight = response.height;
                    winWidth  = response.width;
                    pos = {
                            top:  (winHeight - tbHeight - self.options.size.height) / 2 + tbHeight,
                            left: (winWidth - self.options.size.width) / 2
                    };
                    self.setPosition(
                            pos.top,
                            pos.left
                    );
                });
                return;
            }
            pos = {
                top:  (winHeight - tbHeight - this.options.size.height) / 2 + tbHeight,
                left: (winWidth - this.options.size.width) / 2
            };
        }
        this.setPosition(pos.top, pos.left);
    }
};

suOverlayManager.prototype = {
    _updateShowDisabledStumbleDiv: function() {
        var showDisabledStumbleDiv = false,
            id;

        // Positioning 'floating' overlays
        for (id in this._overlaysTypes.floating) {
            overlay = this._overlays[id];
            if (!overlay.visible) {
                continue;
            }
            if (overlay.options.viewEnabled !== true){
                showDisabledStumbleDiv = true;
            }
        }
        if (showDisabledStumbleDiv) {
            if (this.useExtensionApi) {
                suExtensionApi.message.postMessage({ id: 1 }, "disableStumble");
            }
            else {
                this._disabledStumbleDiv.show();
            }
        }
        else {
            if (this.useExtensionApi) {
                suExtensionApi.message.postMessage({ id: 1 }, "enableStumble");
            }
            else {
                this._disabledStumbleDiv.hide();
            }
        }
    },

    _positionOverlays: function() {
        var win = $(window),
            winWidth = win.width(),
            toolbarHeight,
            overlay,
            id;

        for (id in this._overlays) {
            overlay = this._overlays[id];
            overlay.autoPosition(winWidth);
            overlay.resizeIframe();
        }


        this._updateShowDisabledStumbleDiv();

        // Position top overlays
        this.spaces.top = 0;
        toolbarHeight = $('#tb-toolbar').height();

        for (id in this._overlaysTypes.top) {
            overlay = this._overlays[id];
            if (!overlay.visible) {
                continue;
            }
            overlay.setPosition(toolbarHeight + this.spaces.top, 0, winWidth, overlay.options.size.height);
            if (overlay.iframe) {
                this.spaces.top += overlay.iframe.height();
            } else if(overlay.options.size.height) {
                this.spaces.top += overlay.options.size.height;
            }
        }
    },

    closeOtherOverlays: function(id, others) {
        var type,
            _id;

        if (!others) {
            return;
        }
        if (others === true) {
            for (_id in this._overlays) {
                if (_id != id && this._overlays[_id].visible) {
                    this._overlays[_id].hide();
                }
            }
        }
        else {
            for (type in others) {
                if (typeof this._overlaysTypes[others[type]] == 'undefined') {
                    continue;
                }

                for (_id in this._overlaysTypes[others[type]]) {
                    if (_id != id && this._overlays[_id].visible) {
                        this._overlays[_id].hide();
                    }
                }
            }
        }
        this._positionOverlays();
    },

    onResize: function() {
        this._positionOverlays();
        return this.getSpaces();
    },

    /**
     * @param id: string: unique identifier og the overlay
     * @param options: js object:
     *         - url (required or data provided): url to load in the panel
     *         - data (required or url provided): data to display in the panel
     *         - type (required): floating / tooltip / permanenttooltip / top / notification
     *         - notificationType(only for notification type): error / info
     *         - anchorElement(floating only. optional): a jquery object to anchor to. For floating if not present, center the overlay in the page
     *         - anchorToRight (optional): false (default) / true
     *                 * false: position the left of the popup to the left of the element
     *                 * true:  potision the right of the popup to the right of the element
     *         - size (required):
     *              {
     *                  width (optional): int
     *                  height (optional): int
     *                  max-width (optional): int
     *              }
     *         - refresh (optional): false (default) / true (refresh the panel if called again)
     *         - viewEnabled (optional): false (default) / true: only for 'floating' overlays. if false disable the view (stumble) and add some opacity over it
     *         - closeOthers (optional):
     *                 * false (default)
     *                 * true (hide all other overlays)
     *                 * array : array of (floating | top | bottom | left | right) of which overlays will be removed
     *
     * @param hidden: if true, the overlay will not be displayed and repositioning will not be done
     *                (the overlay is created but not displayed)
     */
    openOverlay: function(id, options, hidden) {
        var overlay;

        // If it exists and they want to refresh it then close it first
        if (typeof this._overlays[id] != 'undefined' && options.refresh) {
            this.closeOverlay(id);
            this.destroyOverlay(id);
        }

        if (typeof this._overlays[id] == 'undefined') {
            overlay = new suOverlay(this.listener, id, options, this.versionString);
            this._overlays[id] = overlay;
            this._overlaysTypes[options.type][id] = overlay;
        }
        else {
            overlay = this._overlays[id];
            if (overlay.options.type != options.type) {
                delete this._overlaysTypes[overlay.options.type][id];
                this._overlaysTypes[options.type][id] = overlay;
            }
        }

        if (!hidden) {
            if (options.closeOthers) {
                this.closeOtherOverlays(id, options.closeOthers);
            }
            overlay.show();
            this._positionOverlays();
        }

        if (!this.useExtensionApi && overlay.iframe) {
            overlay.iframe.on("load", function() {
                overlay.frameLoaded = true;
                $(window).trigger("resize");
            });
        }

        return overlay;
    },

    toggleOverlay: function(id, options) {
        var overlay = this._overlays[id];

        if (typeof overlay == 'undefined') {
            return this.openOverlay(id, options);
        }
        else {
            if (overlay.visible)
            {
                overlay.hide();
                if (overlay.options.viewEnabled !== true){this._positionOverlays();}
                return overlay;
            } else {
                return this.openOverlay(id, options);
            }
        }
    },

    /**
     * returns true if the overlay was opened, visibled and has been closed
     * @param id
     */
    closeOverlay: function(id) {
        var overlay = this._overlays[id];
        if (typeof overlay === 'undefined') {
            // Ugh!  This is our best stop-gap until we get rid of this overlay manager
            if ((id == 'share-panel') && this.useExtensionApi) {
                suExtensionApi.overlay.destroy(id);
            }
            return false;
        }

        if (!overlay.visible) {
            return false;
        }
        overlay.hide();

        this._positionOverlays();
        return true;
    },

    closeAllOverlays: function() {
        var id;

        for (id in this._overlays) {
            this._overlays[id].hide();
        }

        this._positionOverlays();
    },

    destroyOverlay: function(id) {
        var overlay = this._overlays[id];

        if (!overlay) {
            return;
        }

        overlay.hide();
        overlay.remove();
        delete this._overlaysTypes[overlay.options.type][overlay.id];
        delete this._overlays[id];
        this._positionOverlays();
    },

    destroyOverlaysTypes: function(type) {
        var overlay,
            id;

        for (id in this._overlaysTypes[type]) {
            overlay = this._overlays[id];
            overlay.hide();
            overlay.remove();
            delete this._overlaysTypes[type][overlay.id];
            delete this._overlays[id];
        }
        this._positionOverlays();
    },

    /**
     * @param exceptions: array: regular expressions of overlays that should not be destroyed
     */
    destroyAllOverlays: function(exceptions) {
        var fnIsException,
            overlay,
            id;

        fnIsException = function(id) {
            if (exceptions) {
                for (var i=0; i<exceptions.length; i++) {
                    if (id.match(exceptions[i])) {
                        return true;
                    }
                }
            }
            return false;
        };

        for (id in this._overlays) {
            if (fnIsException(id)) {
                continue;
            }
            overlay = this._overlays[id];
            overlay.hide();
            overlay.remove();
            delete this._overlaysTypes[overlay.options.type][overlay.id];
            delete this._overlays[id];
        }
        this._positionOverlays();
    },

    getSpaces: function() {
        return this.spaces;
    },

    repositionOverlay: function(id, size) {
        var overlay = this._overlays[id];
        if (size.width) {
            overlay.options.size.width = size.width;
        }
        if (size.height) {
            overlay.options.size.height = size.height;
        }
        if (overlay.visible) {
            overlay.autoPosition($win.width());
        }
    }
};(function(){
    "use strict";
    /**
     * State Model
     */
    var state = Base.Model.extend({
        defaults: {
            "keyword": "",
            "typed-keyword": "",
            "index": -1
        },

        getTypedKeyword: function() {
            var typedKeyword = this.get("typed-keyword") || ""; // Always needs to at least return an empty string;
            // Remove tabs, spaces, line breaks and trim
            return typedKeyword.replace( /[\s\n\r\t]+/g, " " ).replace(/^\s*([\S\s]*?)\s*$/, "$1");
        }
    });

    /**
     * Result model
     */
    var result = Base.Model.extend({
        idAttribute: "index",

        defaults: {
            label: null,
            matchesInput: false
        },

        getKeyword: function() {
            return this.get("label");
        }
    });

    /**
     * Results Collection
     */
    var results = Base.Collection.extend({
        model: result,

        getByIndex: function(index) {
            var model = this.models[index];
            return model ? model : false;
        },

        /**
         * Get the keyword from the specified index offset
         *
         * @param index
         */
        getKeywordFromIndex: function(index) {
            var model = this.getByIndex(index);
            return model ? model.getKeyword() : false;
        }

    });

    /**
     * Cache Collection
     */
    var CacheIndex = function(config) {
        this._keywords = [];
        this._resultsByKeyword = {};
        this._keywordIndexPositions = {};
        this._keywordAdded = {};
        this._limit = config.limit || 50;
        this._expires = config.expires || 3600000; // Milliseconds: 1 hour default, use 0 to disable
        this._total = 0;

        return this;

    };

    extend(CacheIndex.prototype, {

        addResults: function(keyword, results) {
            this._keywords.push(keyword);
            this._resultsByKeyword[keyword] = results;
            this._keywordIndexPositions[keyword] = this._total++; // Assign the index value and update the total after
            this._keywordAdded[keyword] = (new Date()).getTime();

            if (this._total > this._limit) {
                this.purgeOldResults();
            }

            return this;

        },

        get: function(keyword) {
            var results = this._resultsByKeyword[keyword],
                curTime;

            if (!results) {
                return false;
            }

            if (this._expires > 0) {
                curTime = (new Date()).getTime();

                if ((curTime - this._keywordAdded[keyword]) >= this._expires) {
                    this.remove(keyword);
                    return false;
                }
            }

            return results;

        },

        remove: function(keyword) {
            var index = this._keywordIndexPositions[keyword];

            this._keywords.splice(index, 1);
            delete this._resultsByKeyword[keyword];
            delete this._keywordIndexPositions[keyword];
            delete this._keywordAdded[keyword];
            this._total--;
        },

        purgeOldResults: function() {
            this.remove( this._keywords[0] );
        }

    });

    var CacheLibrary = {
        createIndex: function(config) {

            if (!this[config.instance]) {
                this[config.instance] = new CacheIndex(config || {});
            }

            return this[config.instance];
        }
    };

    /**
     * View
     */
    var view = Base.View.extend({

        initialize: function() {
            this.$input = this.$el;

            var placeholderText = this.$input.attr("placeholder");

            if(!Browser.supports("placeholder")) {
                this.$input.val( this.$input.attr("placeholder") ).addClass("ac-placeholder");

                this.$input
                    .focus((function() {
                        if (this.$input.val() == placeholderText) {
                            this.$input.val("").removeClass("ac-placeholder");
                        }
                    }).bind(this))
                    .blur((function() {
                        if (this.$input.val() === "") {
                            this.$input.val(placeholderText).addClass("ac-placeholder");
                        }
                    }).bind(this));
            }
        },

        $resultsContent: function() {
            if (!this._resultsContent) {
                this._resultsContent = this.$results.find(".ac-results-content");
                this._initialResultsHTML = this._resultsContent.html();
            }

            return this._resultsContent;

        },

        /**
         * Render results
         */
        renderResults: function(collection) {
            var html = "",
                results = collection.models,
                i,
                ii,
                result,
                heading;

            this.trigger("results:before");
            html += "<ul class='ac-results'>";

            //@fixme
            for (i=0, ii=results.length; i<ii; i++) {

                result = results[i];

                heading = result.get("heading");

                if (heading) {

                    if (i > 0) {
                        html += '</ul>';
                    }

                    html += "" +
                        "<h6 class='ac-results-heading'>" + heading + "</h6>" +
                        "<ul class='ac-results'>";
                }

                html += "<li><a href='#' data-index='" + i + "'";

                if (result.get("highlight")) {
                    html += " class='s-ac-selected'";
                }

                html += ">" + result.get("matchedText") + "</a></li>";

            }

            html += "</ul>";

            this.$resultsContent().html(this._initialResultsHTML + html);

            if (results.length === 0) {
                this.noResults();
            }

            this.trigger("results:after");

        },

        noResults: function() {
            this.$results.find(".ac-no-results").show();
        },

        keywordChanged: function(state) {
            this.$input.val(state.get("keyword"));
        },

        indexChanged: function(state) {
            var index = state.getInt("index");

            this.$resultsContent().find(".s-ac-selected").attr("class", "");

            if (index > -1) {
                this.$results.find("[data-index=" + index + "]").addClass("s-ac-selected");
            } else {
                state.set("keyword", state.get("typed-keyword"));
            }

        },

        scrollElementIntoView: function() {
            this.$scrollTarget[0].scrollIntoView();
        },

        toggleLoading: function(state) {

            if (state.get("loading")) {
                this.$input.addClass("s-ac-loading");
            } else {
                this.$input.removeClass("s-ac-loading");
            }

        },

        toggleFocus: function(state) {

            if (state.get("focused")) {
                this.$input.focus();
            } else {

                if (!Browser.supports("touch")) {
                    state.set("open", false);
                }

            }

        },

        toggleResultsDisplay: function(state) {
            var typedKeyword = state.get("typed-keyword");

            if (this._hideTimeout) {
                clearTimeout(this._hideTimeout);
                this._hideTimeout = null;
            }

            if (state.get("open")) {
                this.$results.show();
            } else {

                if (typedKeyword && typedKeyword.length > 1) {
                    this._hideTimeout = setTimeout((function(){
                        this.$results.hide();
                    }).bind(this), 400);
                } else {
                    this.$results.hide();
                }
            }
        }

    });

    /**
     * Controller
     */
    Base.Autocomplete = Base.Controller.extend({
        _lastRequest: 0,
        _timer: null,

        _settings: {
            "delay": 100,
            "auto_focus": false
        },

        // Base initialize`
        initialize: function(config) {
            extend(this._settings, config);

            this._instanceId = ".autocomplete-" + config.id;

            this.keywordBuffer = [];

            this.state = new state();
            this.view = new view(this);

            this.results = new results(this);
            this.results.bind("reset", this.view.renderResults, this.view);

            this.cache = CacheLibrary.createIndex({instance:this.cacheId});

            this.state
                .bind("change:keyword", this.view.keywordChanged, this.view)
                .bind("change:typed-keyword", this.typedKeywordChanged, this)
                .bind("change:index", this.view.indexChanged, this.view)
                .bind("change:index", this.indexChanged, this)
                .bind("change:focused", this.view.toggleFocus, this.view)
                .bind("change:open", this.view.toggleResultsDisplay, this.view);

            if (config.showLoadingState !== false) { // Passes if `undefined` or `true`
                this.state.bind("change:loading", this.view.toggleLoading, this.view);
            }

            /*
             * Remove the loading class when the page unloads, otherwise the user could navigate back in their history and
             * the loading icon will still be animating.
             */
            $(window).bind("unload" + this._instanceId, (function(){
                try {
                    this.state.set("loading", "off");
                } catch(e) {
                    // Don't break
                }
            }).bind(this));

            // Scroll a specific target back into view when device orientation changes
            if (this._settings.scrollTargetSelector && Browser.supports("orientationChange")) {
                this.view.$scrollTarget = $(this._settings.scrollTargetSelector);
                this.state.bind("change:orientation", this.view.scrollElementIntoView, this.view);
                window.onorientationchange = (function() {
                    this.state.trigger("change:orientation");
                }).bind(this);
            }

            this.bindEvents({
                "keyup": "keyInput",
                "blur": "blur"
            });

            this.$results = $(this._settings.resultsSelector);

            // Pass this selector onto the view
            this.view.$results = this.$results;

            this.$results
                .delegate("a", "click", (function(e){
                    e.preventDefault();
                    this.selectResult($(e.target).data("index"));
                }).bind(this))
                .delegate("a", "hover", (function(e){
                    this.setIndex($(e.target).data("index"));
                }).bind(this));

            if (this._settings.auto_focus) {
                this.state.set("focused", true);
            }

            this.init(config);

        },

        indexChanged: function(event, data, newIndex) {

            if (newIndex > -1) {
                this.state.set("keyword", this.results.getKeywordFromIndex(newIndex));
            } else {
                this.state.set("keyword", this.state.get("typed-keyword"));
            }

        },

        typedKeywordChanged: function(state) {
            var curVal = state.getTypedKeyword();

            if (curVal && curVal.length > 1) {
                this.queueRequest();
            } else {
                this.state.set("open", false);
                this.results.reset();
            }

        },

        /**
         * Keypress handler
         */
        keyInput: function($this, e) {
            var index = this.state.getInt("index"),
                newIndex = false,
                newKeyword = false,
                lastIndex = this.results.length - 1,
                typedKeyword = this.state.get("typed-keyword") || "";

            lastIndex = lastIndex > -1 ? lastIndex : 0;
            this.state.set("loading", false);

            if (e.which != 13 && e.which != 38 && e.which != 40) {
                var value = $this.val();

                if (value != typedKeyword) {
                    this.state.set("typed-keyword", value);
                }
                return;
            }

            if (e.which === 13 /*Enter*/) {

                if (this.keywordBuffer.length === 0) {
                    this.submit();
                } else {
                    this.bind("keyword:done", (function() {

                        if (this.keywordBuffer.length === 0) {
                            this.submit();
                        }

                    }).bind(this));
                }
            }

            // If there are no results or the list isn't open, don't bother trying to cycle through it.
            if (!this.results.models.length || !this.state.get("open")) {
                return;
            }

            if (e.which === 38 /*Up*/) {
                newIndex = index > -1 ? index - 1 : lastIndex;
            }

            if (e.which === 40 /*Down*/) {
                newIndex = index != lastIndex ? index + 1 : -1;
            }

            if (newIndex !== false) {
                this.state.setInt("index", newIndex);
            }
        },

        blur: function() {
            this.state.set("focused", false);
        },

        /**
         * Submit
         */
        submit: function() {
            var index = this.state.getInt("index"),
                result;

            if (index === -1) {
                result = this.results.getByIndex(0);

                if (result && result.get("matchesInput") === true) {
                   this.state.setInt("index", 0);
                    this._resultSelected(0);
                } else {
                    this.view.noResults();
                }

            } else {
                // .resultSelected is a method that should exist within the object that extends Base.Autocomplete
                this._resultSelected(index);
            }

        },

        setIndex: function(index) {
            this.state.setInt("index", index);
        },

        /**
         * Select an item from the result list
         */
        selectResult: function(index){
            var model = this.results.getById(index);

            this.state.trigger("change:orientation");
            this.state.set("keyword", model.get("label"));
            this.submit();
        },

        /**
         * Queue a lookup request to the server
         */
        queueRequest: function() {
            var toDelay = this._settings.delay,
                curTime = (new Date()).getTime(),
                timeDiff = (curTime - this._lastRequest);

            if (timeDiff < this.delay) {
                toDelay = this.delay - timeDiff;
            }

            if (this._timer) {
                clearTimeout(this._timer);
                this._timer = null;
            }

            this._timer = setTimeout((function(){
                this.sendRequest();
            }).bind(this), toDelay);

        },

        /**
         * Send the request to the server
         */
        sendRequest: function(){
            var keyword = this.state.getTypedKeyword(),
                cache = this.cache.get(keyword);

            this._lastRequest = (new Date()).getTime();

            this.keywordBuffer.push(keyword);

            if (this._requestProcessing) {
                this._requestProcessing.abort();
            }

            if (cache) {
                this.state.setInt("index", -1);
                this._prepareData(cache);
                this._requestProcessing = null;
                this.trigger("keyword:done");
                this.keywordBuffer = this.keywordBuffer.splice(1, this.keywordBuffer.length);

                return;
            }

            this._requestProcessing = this.sync.create(
                // Data
                {
                    "q": keyword,
                    "_token": this._settings._token
                },

                // Ajax params
                {
                    cache: false,

                    success: (function(response){
                        this.keywordBuffer = this.keywordBuffer.splice(1, this.keywordBuffer.length);
                        this._lastRequest = (new Date()).getTime();

                        if (response._success) {
                            this.state.setInt("index", -1);
                            this._prepareData(response.data);
                            this.cache.addResults(keyword, response.data);
                            this.trigger("keyword:done");
                        }

                    }).bind(this),

                    error: (function(){
                        //$todo
                        this.trigger("keyword:done");
                        this.keywordBuffer = this.keywordBuffer.splice(1, this.keywordBuffer.length);
                    }).bind(this)

                }
            );
        },

        _prepareData: function(data) {
            var hasResults = false,
                results = [],
                result,
                index = 0,
                categories = data.categories,
                category,
                pattern = this.state.getTypedKeyword().replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"),
                c,
                cc,
                r,
                rr;

            if (!categories || categories && categories.length > 0) {
                this.results.reset();
            }

            for (c=0, cc=categories.length; c<cc; c++) {
                category = categories[c];

                // Loop through the results under each category
                for (r = 0, rr = category.keywords.length; r<rr; r++) {
                    result = category.keywords[r];
                    result.index = index;

                    if (r === 0 && category.label != "default") {
                        result.heading = category.label;
                    }

                    if (result.highlight) {
                        result.matchesInput = true;
                    }

                    var regexObj = new RegExp(pattern, "ig");
                    var replaceWith = regexObj.exec(result.label);

                    result.matchedText = result.label.replace(regexObj, "<strong>"+replaceWith+"</strong>");
                    results.push(result);
                    index++;

                }
            }

            this.results.reset(results);
            this.state.set("open", true);

        },

        _resultSelected: function(index) {
            this.state.set("loading", true);
            this.resultSelected( this.results.getByIndex(index) );
            this.state.set("open", false);
        }

    });
}).call(this);(function(){
    function resultsTemplate(id) {
        return "" +
        "<div class='ac-results-wrap' id='" + id + "'>" +
            "<div class='ac-results-content'>" +
                "<div class='ac-no-results explore-no-results'>" +
                    "<h6>No Results Found.</h6>" +
                    "<p>Please try exploring another interest.</p>" +
                "</div>" +
            "</div>" +
        "</div>";
    }


    function exploreBoxInit(config) {
        config.selector = "#" + config.id;

        var resultsId = config.id + "-results-wrap";

        config.resultsSelector = "#" + resultsId;

        $(config.selector).after( resultsTemplate(resultsId) );

        var ExploreBox = Base.Autocomplete.extend({
            selector: config.selector,

            cacheId: "ExploreBox",

            restURL: "/su/api/keyword-autocomplete",

            init: function() {
                this.config = config;

                var instance = this;

                if (config.context == 'overlay') {
                    if((typeof(suExtensionApi) != "undefined") && suExtensionApi.isReady()) {
                        instance.initOverlay(instance);
                    }
                    else
                    {
                        if (window.addEventListener)
                            window.addEventListener("suScriptReadyExtensionApi", function(){instance.initOverlay(instance);}, false);
                        else if (window.attachEvent)
                            window.attachEvent("suScriptReadyExtensionApi", function(){instance.initOverlay(instance);}, false);
                    }
                }

                if (config.context == 'toolbar') {
                    if((typeof(suExtensionApi) != "undefined") && suExtensionApi.isReady()) {
                        instance.initToolbar(instance);
                        return;
                    }
                    else
                    {
                        if (window.addEventListener)
                            window.addEventListener("suScriptReadyExtensionApi", function(){instance.initToolbar(instance);}, false);
                        else if (window.attachEvent)
                            window.attachEvent("suScriptReadyExtensionApi", function(){instance.initToolbar(instance);}, false);
                    }
                }
            },

            initOverlay: function(instance)
            {
                suExtensionApi.message.addListener(instance.overlayMessageListener);
                instance.state
                    .bind("change:open", function(data, value) {
                        suExtensionApi.message.postMessage(suExtensionApi.overlay.opener, 'openAutocompleteOverlay', value[1]);
                        instance.updateOverlaySize();
                        suExtensionApi.message.postMessage(suExtensionApi.overlay.opener, 'state:open', value[1]);
                    })
                    .bind("change:keyword", function(data, value) {
                        suExtensionApi.message.postMessage(suExtensionApi.overlay.opener, 'state:keyword', value[1]);
                    });

                instance.results
                    .bind("add", instance.sendResultsToToolbar, instance)
                    .bind("remove", instance.sendResultsToToolbar, instance)
                    .bind("reset", instance.sendResultsToToolbar, instance);

                SU.Overlay.addOAuthToSync(instance.sync);
            },

            initToolbar: function(instance)
            {
                suExtensionApi.message.addListener(instance.toolbarMessageListener);
                if((typeof(SU.WebToolbar) != "undefined") && SU.WebToolbar.isReady()) {
                    instance.openOverlay(true);
                }
                else
                {
                    if (window.addEventListener)
                        window.addEventListener("suScriptReadyWebToolbar", function(){instance.openOverlay(true);}, false);
                    else if (window.attachEvent)
                        window.attachEvent("suScriptReadyWebToolbar", function(){instance.openOverlay(true);}, false);
                }


                instance.state
                    // unbind default autocomplete events for toolbar. We're going to handle these in this class.
                    .unbind("change:typed-keyword")
                    .unbind("change:index")
                    .unbind("change:focused")
                    .unbind("change:open")
                    // bind our methods to the events we unbound earlier
                    .bind("change:typed-keyword", function(data, value) {instance.sendStateUpdateToOverlay('typed-keyword', value);})
                    .bind("change:index",         function(data, value) {instance.sendStateUpdateToOverlay('index', value);})
                    .bind("change:focused",       function(data, value) {
                        // delay here to accomodate for clicks on the autocomplete overlay
                        // otherwise, we will close it before the click handler is triggered
                        window.setTimeout(function() {
                            instance.sendStateUpdateToOverlay('focused', value);
                        }, 300);
                    });
                instance.view.bind("results:after", function(){
                    suExtensionApi.message.postMessage({ id: 'keyword-autocomplete-' + suExtensionApi.getId()}, 'updateOverlaySize');
                });
            },

            sendResultsToToolbar: function(data)
            {
                suExtensionApi.message.postMessage(suExtensionApi.overlay.opener, 'newResults', data.models);
            },

            sendStateUpdateToOverlay: function(key, value) {
                value = value[0];
                suExtensionApi.message.postMessage({ id: 'keyword-autocomplete-' + suExtensionApi.getId()}, 'state', { key: key, value: value });
            },

            openOverlay: function(hide) {
                SU.WebToolbar.overlayManager.openOverlay('keyword-autocomplete-' + suExtensionApi.getId(), {
                    url: "/su/overlay/explorebox/",
                    type: 'floating',
                    anchorElement: $(config.selector),
                    size: {width: 216, height: $(config.resultsSelector).outerHeight()},
                    closeOthers: ['floating', 'notification']
                }, hide);
            },

            closeOverlay: function() {
                SU.WebToolbar.overlayManager.closeOverlay('keyword-autocomplete-' + suExtensionApi.getId());
            },

            overlayMessageListener: function(id, data, sender)
            {
                switch (id) {
                    case 'state':
                        SU.ExploreBox.state.set(data.key, data.value);
                        break;
                    case 'updateOverlaySize':
                        SU.ExploreBox.updateOverlaySize();
                        break;
                }
            },

            toolbarMessageListener: function(id, data, sender)
            {
                switch (id)
                {
                    case 'openAutocompleteOverlay':
                        if (data == true)
                            SU.ExploreBox.openOverlay(false);
                        else
                            SU.ExploreBox.closeOverlay();
                        break;
                    case 'state:open':
                        SU.ExploreBox.state.set("open", data)
                        break;
                    case 'state:keyword':
                        SU.ExploreBox.state.set("keyword", data)
                        break;
                    case 'newResults':
                        if (data)
                            SU.ExploreBox.results.reset(data);
                }
            },

            updateOverlaySize: function()
            {
                // don't resize if there are no results
                if (SU.ExploreBox.results.length == 0)
                    return;

                var container = $(config.resultsSelector);
                position = {
                    width:  216,
                    height: $(container).outerHeight()
                }

                // Update the parent overlay
                suExtensionApi.overlay.update(suExtensionApi.getId(), { position: position });

                // And tell the overlay manager the true width/height of this overlay so it can position it properly
                var data = {
                    id: suExtensionApi.getId(),
                    size: position
                };
                suExtensionApi.message.postMessage(suExtensionApi.overlay.opener, "resizePanel", data);
            },

            resultSelected: function(model) {
                var data = model.toJSON();
                var mode = {};
                mode.contextual = data.label;

                // TODO: remove this, because the server should send the correct data
                if (data.mode == 'topic')
                {
                    mode.mode = 'topic';
                    mode.topic = data.topicid;
                }
                else
                {
                    mode.mode = 'tag';
                    mode.q = data.label;
                }
                SU.ToolbarAction.stumble(mode);
            }
        });

        SU.ExploreBox = new ExploreBox(config);
    }

    SU.addInit("mExploreBoxWebToolbar", function(config){
        exploreBoxInit(config);
    });
}).call(this);/**
 * toolbar_action.js
 *
 * Facade to send calls to the toolbars
 *
 * @author fabrice
 */
(function(){
    SU.ToolbarAction = {

        _hasCorrectExtension: function() {
            if (typeof suExtensionApi == "undefined") {
                return false;
            }

            var info = suExtensionApi._info;
            if (!info) {
                return false;
            }

            if ($.inArray(info.provider, ["webtb", "ios", "android"]) > -1) {
                return true;
            }

            if ((info.provider == "chromebar") && (parseInt(info._providerVersion) >= 4)) {
                return true;
            }

            return false;
        },

        _getWebTb: function() {
            if (SU.WebToolbar) {
                return SU.WebToolbar;
            } else if (top.SU && top.SU.WebToolbar) {
                return top.SU.WebToolbar;
            }
            return null;
        },

        _getChromebar: function() {
            try {
                var el = document.getElementById("__su__tbcont");
                if(el) {
                    return el.contentWindow;
                }
            } catch (err) {}
            return null;
        },

        _convertModeToChromebar: function(mode) {
            // Copy the existing mode, then change it
            var modeCopy = jQuery.extend({}, mode);
            var chromebar_mode = {mode: modeCopy};
            chromebar_mode.mode.method = mode.mode;
            if (chromebar_mode.mode.method == 'videos'){chromebar_mode.mode.method = 'video';}else if (chromebar_mode.mode.method == 'photos')
            {
                chromebar_mode.mode.mode   = 'topic';
                chromebar_mode.mode.method = 'topic';
                chromebar_mode.mode.topic  = 302;
            }
            delete chromebar_mode.mode.mode;
            if (mode.contextual)
            {
                chromebar_mode.label = mode.contextual;
            }
            return chromebar_mode;
        },
        /**
         * Tell the toolbar to start stumbling.
         * if mode is null, the current mode is not changed
         * if a nextpid is given, the mode (if not null) will change
         * but the next displayed stumble is the nextpid given
         * nextpid can also be passed as a property in the mode object (precedence to the second arg)
         */
        stumble: function(mode, nextpid) {
            if (!nextpid && mode != null && typeof mode.nextpid != 'undefined'){nextpid = mode.nextpid;}

            // Check if mozbar installed
            if (typeof suExtensionApi != 'undefined' && suExtensionApi.getProviderInfo)
            {
                suExtensionApi.getProviderInfo(function(info){providerInfo = info;});
                if (providerInfo.provider == "mozbar")
                {
                    if (mode != null)
                    {
                        // The old mozbar has slightly different mode formats
                        if (providerInfo.apiVersion == "1.0")
                        {
                            mode.method = mode.mode;
                            if (mode.mode == 'stumblethru'){mode.domain = mode.partner;}
                            if (mode.mode == 'topic'){mode.topicid = mode.topic;}
                            if (mode.mode == 'tag'){mode.tag = mode.q;}
                            if (mode.mode == 'instumbler' && mode.stumblername){mode.stumbler = mode.stumblername + '';} // We need to be sure we have a string and not a number here
                            if (mode.mode == 'stumblelist') {mode.listid = mode.s_prefixed_listid.substring(1);}

                            if (mode.mode == 'photos')
                            {
                                mode.method  = 'topic';
                                mode.topicid = 302;
                            }
                            if (mode.mode == 'all'){mode.method = 'general';}
                            if (mode.mode == 'videos'){mode.method = 'video';}
                            if (mode.mode == 'channels'){mode.method = 'channel';}
                        }
                        suExtensionApi.stumble.setMode(mode);
                    }

                    if (nextpid)
                    {
                        try {
                            window.top.location.href = '/su/' + nextpid;
                            return true;
                        } catch (err) {}
                        window.location.href = '/su/' + nextpid;
                    } else {suExtensionApi.stumble.stumble();}
                    return true;
                }
                else if (providerInfo.provider == "chromebar")
                {
                    if (mode == null && suExtensionApi.stumble)
                    {
                        suExtensionApi.stumble.stumble();
                        return true;
                    }

                    // todo:  Why is this necessary?  Something seems whack
                    delete mode.stumblername;

                    // New toolbars directly support stumble functionality
                    suExtensionApi.stumble.setMode(mode, function() {
                        if (nextpid)
                        {
                            try {
                                window.top.location.href = '/su/' + nextpid;
                            } catch (err) {}
                            window.location.href = '/su/' + nextpid;
                        } else {suExtensionApi.stumble.stumble();}
                    });
                    return true;
                }
                else if (providerInfo.provider == "ios" || providerInfo.provider == "android")
                {
                    if (mode)
                    {
                        switch (mode.mode)
                        {
                            case 'instumbler':
                                mode.mode    = 'user';
                                mode.userids = [ mode.stumbler ];
                                break;

                            case 'stumblethru':
                                mode.mode    = 'domain';
                                mode.domains = [ mode.partner ];
                                break;

                            case 'tag':
                                mode.mode    = 'keyword';
                                mode.keyword = mode.q;
                                break;

                            case 'topic':
                                mode.mode      = 'interest';
                                mode.interests = [ mode.topic ];
                                break;

                            case 'friends':
                                mode.mode = 'following';
                                break;

                            case 'related_url':
                                mode.url = mode.related_url;
                                break;

                            case 'videos':
                                mode.mode      = 'video';
                                mode.interests = [ mode.topic ];
                                mode.domains   = [ mode.partner ];
                                break;
                        }
                    }
                }
            }

            if (mode != null){delete mode.stumblername;}

            // Check if webtb suExtensionApi present
            if (this._hasCorrectExtension())
            {
                if (mode){suExtensionApi.message.broadcastMessage('externalModeSelect', mode);}
                suExtensionApi.message.postMessage(suExtensionApi.overlay.opener, 'stumbleNow', true);
                return true;
            }

            // Check if webtoolbar installed without suExtensionApiWebTb instantiated
            var _webtb = this._getWebTb();

            if (_webtb)
            {
                try
                {
                    if (mode)
                    {
                        _webtb.setStumblingMode(mode);
                        if (mode.contextual){_webtb.setModeLabel(mode.contextual);}
                    }
                    _webtb.performStumble(null, nextpid);
                    return true;
                }
                catch (err) {
                }
            }

            // We fallback to a basic link because we don't have any toolbar installed
            return this._stumblelink(mode, nextpid);
        },

        _stumblelink: function(mode, nextpid) {
            var stumblelink = '/to/stumble/go';
            if (mode)
            {
                switch (mode.mode)
                {
                case 'topic':
                    if (mode.topic){stumblelink = '/to/stumble/topic:' + mode.topic;}
                    break;
                case 'videos':
                case 'news':
                case 'photos':
                case 'friends':
                    stumblelink = '/to/stumble/metatopic:' + mode.mode;
                    break;
                case 'instumbler':
                    if (mode.stumbler){stumblelink = '/to/stumble/stumbler:' + mode.stumbler;}
                    break;
                case 'stumblethru':
                    if (mode.partner){stumblelink = '/to/stumble/stumblethru:' + mode.partner;}
                    break;
                case 'tag':
                    if (mode.q){stumblelink = '/to/stumble/tag:' + mode.q;}
                    break;
                case 'stumblelist':
                    // We use s_prefixed_listid because jquery data attributes are cast as floats for big numbers
                    if (mode.s_prefixed_listid) {
                        stumblelink = '/to/stumble/stumblelist:'+mode.s_prefixed_listid.substring(1);
                    }
                }
            }

            if (nextpid) {
                stumblelink += ';pid=' + nextpid;
            }
            stumblelink += ';src=website';
            if (nextpid && mode.m){stumblelink += '?m=' + encodeURIComponent(mode.m);}
            try {
                window.top.location.href = stumblelink;
                return true;
            } catch (err) {}
            window.location.href = stumblelink;

            return true;
        },

        _getFullPath: function(url) {
            var ourOrigin,
                regex,
                match;
            // Turn relative paths into full paths
            if (url.match(/^https?:/))
                return url;

            // If it starts with '/', then append it to our domain
            if (url.indexOf("/") === 0) {
                regex = /^https?:\/\/[^\/]*/;
                ourOrigin = document.location.href.match(regex)[0];
                url = ourOrigin + url;
                return url;
            }

            // It doesn't start with '/' or 'https?:', use the current path to build the url
            regex = /(.*\/)/; // Greedily grab everything up to the last /
            match = document.body.baseURI.match(regex);
            url = match[0] + url;
            return url;
        },

        rate: function(pid, rating) {
            // Check if suExtensionApi present
            if (this._hasCorrectExtension())
            {
                suExtensionApi.message.postMessage(suExtensionApi.overlay.opener, 'rate', {pid: pid, rating: rating});
            }
            else
            {
                var _webtb = this._getWebTb();
                if (_webtb)
                {
                    if (_webtb.currentStumble.publicid == pid
                            && $.inArray(rating, [1, 0, -1]) != -1){_webtb.performRating(rating);}
                }
            }
        },

        subrate: function(pid, subrating) {
            if (this._hasCorrectExtension())
            {
                suExtensionApi.message.postMessage(suExtensionApi.overlay.opener,
                        'thumbDownMenu_subrate',
                        {pid: pid, subrating: subrating});
            }
            else
            {
                var _webtb = this._getWebTb();
                if (_webtb)
                {
                    _webtb.onMessage('thumbDownMenu_subrate', {
                        pid: pid,
                        subrating: subrating
                    }, null);
                }
            }
        },

        blocksite: function(pid, blocksite) {
            if (this._hasCorrectExtension())
            {
                suExtensionApi.message.postMessage(suExtensionApi.overlay.opener,
                        'thumbDownMenu_blocksite',
                        {pid: pid, blocksite: blocksite});
            }
            else
            {
                var _webtb = this._getWebTb();
                if (_webtb)
                {
                    _webtb.onMessage('thumbDownMenu_blocksite', {
                        pid: pid,
                        blocksite: blocksite
                    }, null);
                }
            }
        },

        showShare: function(sharePid, sharedUrl, webbarUrl) {
            sharedUrl = this._getFullPath(sharedUrl);
            webbarUrl = this._getFullPath(webbarUrl);
            if (suExtensionApi && suExtensionApi.overlay && suExtensionApi.overlay.showUrlWithOverlay) {
                var messageUrl = '/su/overlay/sharemsg?sharepid=' + encodeURIComponent(sharePid) + '&markseen=1';
                messageUrl = this._getFullPath(messageUrl);
                var options = {
                    url: messageUrl,
                    position: { top: 0, height: 40 },
                    css: {
                        "width": "100%",
                        "box-shadow" : "2px 6px 6px rgba(0,0,0,0.2), -2px 6px 6px rgba(0,0,0,0.2)",
                        "background-color" : "#F1F1EE"
                    }
                };
                suExtensionApi.overlay.showUrlWithOverlay(sharedUrl, 'share-panel', options);
            } else {
                SU.ToolbarAction.navigateWithOAuth(webbarUrl);
            }
        },

        openSharePanel: function(pid) {
            if (this._hasCorrectExtension())
            {
                var info = suExtensionApi._info;
                if (suExtensionApi.overlay.opener) {
                    var target = suExtensionApi.overlay.opener;
                } else if (info.provider == 'chromebar') {
                    var target = document.getElementById('__su__toolbar').contentWindow.suExtensionApi;
                }

                suExtensionApi.message.postMessage(target, 'showSharePanel', {pid: pid});
            }
            else
            {
                var _webtb = this._getWebTb();
                if (_webtb)
                {
                    _webtb.showSharePanel(pid);
                }
            }
        },

        showShareMessageReply: function(pid) {
            if (this._hasCorrectExtension())
            {
                if (suExtensionApi.message.postToCurrentBar) {
                    suExtensionApi.message.postToCurrentBar('showShareMessageReply', pid);
                } else {
                    suExtensionApi.message.postMessage(suExtensionApi.overlay.opener, 'showShareMessageReply', pid);
                }
            }
            else
            {
                var _webtb = this._getWebTb();
                if (_webtb)
                {
                    _webtb.onMessage('showShareMessageReply', pid, null);
                }
            }
        },

        displayNotification: function(data) {
            if (this._hasCorrectExtension())
            {
                suExtensionApi.message.postMessage(suExtensionApi.overlay.opener, 'displayNotification', data);
                return true;
            }
            else
            {
                var _webtb = this._getWebTb();
                if (_webtb)
                {
                    try
                    {
                        _webtb.displayNotification(data);
                    }
                    catch (err)
                    {
                        return false;
                    }
                    return true;
                }
            }
            return false;
        },

        closeOverlay: function(data) {
            if (this._hasCorrectExtension())
            {
                if (suExtensionApi.message.postToCurrentBar)
                    suExtensionApi.message.postToCurrentBar('overlayClose', data);
                else
                    suExtensionApi.message.postMessage(suExtensionApi.overlay.opener, 'overlayClose', data);
            }
            else
            {
                var _webtb = this._getWebTb();
                if (_webtb)
                {
                    _webtb.overlayManager.closeOverlay(data);
                }
            }
        },

        destroyOverlay: function(id) {
            var _webtb;

            if (this._hasCorrectExtension()) {
                if (suExtensionApi.message.postToCurrentBar)
                    suExtensionApi.message.postToCurrentBar('overlayDestroy', id);
                else
                    suExtensionApi.message.postMessage(suExtensionApi.overlay.opener, 'overlayDestroy', id);
            }
            else {
                _webtb = this._getWebTb();
                if (_webtb)
                    _webtb.overlayManager.destroyOverlay(id);
            }
        },

        handleImplication: function(data) {
            if (this._hasCorrectExtension()) {
                    suExtensionApi.message.postMessage(suExtensionApi.overlay.opener, 'handleImplication', data);
            } else {
                var _webtb = this._getWebTb();
                if (_webtb) {
                    _webtb.handleImplication(data);
                }
            }
        },

        implicationSubmit: function(response) {
            if (this._hasCorrectExtension()) {
                suExtensionApi.message.postMessage(suExtensionApi.overlay.opener, 'implicationSubmit', response);
            } else {
                var _webtb = this._getWebTb();
                if (_webtb) {
                    _webtb.handleImplication(data);
                }
            }
        },

        resizePanel: function(data) {
            if (this._hasCorrectExtension())
            {
                suExtensionApi.message.postMessage(suExtensionApi.overlay.opener, 'resizePanel', data);
            }
            else
            {
                var _webtb = this._getWebTb();
                if (_webtb)
                {
                    _webtb.overlayManager.repositionOverlay(data.id, data.size);
                }
            }
        },

        navigateWithOAuth: function(url) {
            // If there's no extension api then just navigate the top frame
            if (!suExtensionApi || !suExtensionApi.litebar) {
                window.top.location = url;
                return;
            }

            // Convert it to a full path
            url = this._getFullPath(url);

            // Make sure the url we are adding the tokens to is for our own domain
            var regex = /^https?:\/\/([^\/]*?)(\/|$)/;
            var match = url.match(regex);
            if (!match || (match[1] != document.domain)) {
                window.top.location = url;
                return;
            }

            suExtensionApi.litebar.getOAuthInfo(function(info) {
                if (info) {
                    // We are going to append credentials, make sure we're using https
                    if(url.match(/^http\:/))
                        url = url.replace("http:", "https:");

                    // Now append the args (respecting any existing url args)
                    var argIndex = url.indexOf('?');
                    if (argIndex == -1)
                        url += '?';
                    else
                        url += '&';
                    url += 'x_su_consumer_key=' + info.consumer_key + '&x_su_access_token_key=' + info.token;

                    suExtensionApi.litebar.setContentLocation(url);

                } else {
                    window.top.location = url;
                }
            });
        },

        /**
         * If we are using an extension with OAuth credentials, this function will ensure we
         * open an authenticated session before navigating a site url.
         */
        sessionNavigate: function(url) {
            // If there's no extension api then just navigate the top frame
            if (!suExtensionApi || !suExtensionApi.litebar) {
                window.top.location = url;
                return;
            }

            suExtensionApi.litebar.getOAuthInfo(function(info) {
                if (info) {
                    // Build the session url with the tokens and the final landing page
                    var sessionUrl = "/su/api/startSession";
                    sessionUrl += '?x_su_consumer_key=' + info.consumer_key + '&x_su_access_token_key=' + info.token;
                    sessionUrl += '&url=' + encodeURIComponent(url);
                    suExtensionApi.litebar.setContentLocation(sessionUrl);

                } else {
                    window.top.location = url;
                }
            });
        },

        /**
         * logs the toolbar in
         * expects data to contain an array of data with the keys userid, hashedPassword and username
         *
         * currently this function only sure to work for mozbar
         *
         */
        login: function(data) {
            // Wait for the extension API to be available and ready
            if((typeof(suExtensionApi) == "undefined") || !suExtensionApi.isReady())
            {
                // Wait for the script ready event
                if (window.addEventListener){window.addEventListener("suScriptReadyExtensionApi", SU.ToolbarAction.doLogin(data), false);}else if (window.attachEvent){window.attachEvent("suScriptReadyExtensionApi", SU.ToolbarAction.doLogin(data));}
            }
            else
            {
                SU.ToolbarAction.doLogin(data);
            }

        },

        /*
         * performs a Sync(url).update, but adds OAuth params if they are available from the extension api
         *
         */
        syncUpdateWithOAuth: function(url, params, fnComplete) {
            try {
                suExtensionApi.litebar.getOAuthInfo(function(info){
                    params.x_su_consumer_key     = info.consumer_key;
                    params.x_su_access_token_key = info.token;
                    Sync(url).update(params).complete(fnComplete);
                });
            } catch (err) {
                Sync(url).update(params).complete(fnComplete);
            }
        },

        /**
         * This function actually does the login...currently works only with mozbar
         *
         */
        doLogin: function(data) {
            var do_login = 0, provider, version;
            suExtensionApi.getProviderInfo(function(info){provider = info.provider;version=info.providerVersion;});
            if (provider == 'mozbar' && parseFloat(version) >= 3.73){do_login = 1;}
            if (do_login && typeof(suExtensionApi) != "undefined") {
                suExtensionApi.message.broadcastMessage("msgLogin", data);
                location.reload();
            }
        },

        /**
         * Sends the new list of topics for the currently logged in user to the toolbar
         * @param topics: an object or an array.  If an object, then in the form:
         *          { topicid: topicname, topicid: topicname, ...}
         *          { 504: 'Photography', 21: 'Music', ...}
         *
         *      If an array then just an array of topic ids:
         *          [ "38", "49", "224", ... ]
         */
        updateTopics: function(topics) {
            try {
                if (suExtensionApi && suExtensionApi.oldbar && suExtensionApi.oldbar.processCommands)
                {
                    var command = "UPDATETOPICS ";
                    var isArray = (typeof(topics.length) != "undefined");
                    for (var key in topics) {
                        var topicId = isArray ? topics[key] : key;
                        command += topicId + " ";
                    }
                    suExtensionApi.oldbar.processCommands(command);
                }
            } catch (err) {}
        },

        /**
         * Invokes a callback when the extension api is ready
         *
         * @param callback: function(found)
         *                  Invokes the callback with found=true if the extension API was found
         *                  Invokes the callback with found=false if the wait timed out
         * @param timeout:  ms to wait for the extension api before calling callback(false) if it is not found
         */
        waitForExtensionApi: function(callback, timeout) {
            var finished = false;
            if ((typeof(suExtensionApi) != 'undefined') && suExtensionApi.isReady()) {
                callback(true);
                return;
            }

            if (timeout) {
                window.setTimeout(function() {
                    if (!finished) {
                        finished = true;
                        callback(false);
                    }
                }, timeout);
            }

            window.addEventListener('suScriptReadyExtensionApi', function() {
                if (!finished) {
                    finished = true;
                    callback(true);
                }
            }, false);
        }
    };

    SU.addInit("toolbarLogin", function(data) {
        SU.ToolbarAction.login(data);
    });
}).call(this);(function() {
    SU.ServicesAuth = function() {

        var _callbacks = {};

        var _services = {
            facebook: true,
            twitter: true,
            linkedin: true,
            google: true,
            gmail: true,
            yahoo: true
        };

        function _getAuthUrl(service, method, params) {
            var url,
                urls = {};

            method = method || 'connect';

            switch (service) {
                case "facebook":
                    urls = {
                        autoshare: "/service/facebook/autoshare/request",
                        connect: "/service/facebook/connect/request",
                        login: "/service/facebook/login/request",
                        register: "/service/facebook/register/request",
                        signup: "/service/facebook/signup/request",
                        captcha: "/service/facebook/captcha/request",
                        channels: "/dt/settings/connections/facebook/request?service=facebook"
                    };
                    break;

                case "twitter":
                    urls = {
                        connect: "/service/twitter/connect/request",
                        channels: "/dt/settings/connections/twitter/request?service=twitter"
                    };
                    break;

                case "linkedin":
                    urls = {
                        connect: "/service/linkedin/connect/request"
                    };
                    break;

                case "google":
                    urls = {
                        connect: "/service/google/connect/request",
                        register: "/service/google/register/request"
                    };
                    break;

                case "gmail":
                    urls = {
                        connect: "/service/gmail/connect/request"
                    };
                    break;

                case "yahoo":
                    urls = {
                        connect: "/service/yahoo/connect/request"
                    };
                    break;

            }

            url = urls[method];

            if (typeof (params) !== 'undefined') {
                // Additional parameters were specified for the Url.
                url = url + '?' + $.param(params);
            }

            return url;
        }

        return {

            services: _services,

            bind: function(service, callback) {
                if (_callbacks[service]) {
                    _callbacks[service].push(callback);
                } else {
                    _callbacks[service] = [callback];
                }
                return this;
            },

            load: function(source) {
                var context = source.data('context') || '';

                if (typeof(_kmq) !== 'undefined') {
                    _kmq.push(['record', 'Clicked Facebook Button', {'Context': context}]);
                }

                window.top.location = _getAuthUrl(source.data('service'), source.data('method'), {
                    success: source.data('success') || document.URL,
                    fail: source.data('fail') || document.URL,
                    context: context,
                    scope: source.data('scope') || ''
                });
            },

            open: function(service, method, params) {
                if (typeof(_kmq) !== 'undefined') {
                    _kmq.push(['record', 'Clicked Facebook Button', {'Context': method}]);
                }

                window.open(_getAuthUrl(service, method, params), "auth_" + service, "menubar=1,resizable=1,width=1000,height=600");
            },

            result: function(response, window_ref) {
                //this is to close the window calling the response, if required
                if(typeof window_ref !== 'undefined') {
                   window_ref.close();
                }

                for ( var i = 0, callback; callback = _callbacks[response.service][i]; i++) {
                    callback(response._success, response);
                }
            }
        };
    }();

    // Bind service connection buttons.
    $("body").on('click', '.connect-service', function() {
        SU.ServicesAuth.load($(this));
    });

}).call(this);define(function(require) {
    var mediator = require("module/mediator"),
        TrackingModule;

    TrackingModule = function(view) {
        this.view = view;
        this.mediator = mediator;

        this.mediator.on("tracking:getModel", this.getModel, this);
    };

    TrackingModule.prototype = {
        getModel: function(e, fn) {
            var model,
                index;

            if (this.view.$el.has(e.currentTarget).length) {
                model = this.view.getClosestById(e);
                index = $(e.currentTarget).closest("article").index();
                fn(model, index);
            }
        }
    };

    return TrackingModule;
}, "module/tracking");define(function(require) {
    return {
        setCaretPosition: function($el) {
            var elem = $el.get(0),
                caretPos = $el.val().length;

            if (elem) {
                try {
                    if(caretPos && elem.setSelectionRange) {
                        elem.focus();
                        elem.setSelectionRange(caretPos,caretPos);
                    } else if (caretPos && elem.createTextRange) {
                        var range = elem.createTextRange();
                        range.collapse(true);
                        range.moveEnd('character', caretPos);
                        range.moveStart('character', caretPos);
                        range.select();
                    } else {
                        elem.focus();
                    }
                } catch (e) {
                    elem.focus();
                }
            }
        },

        toTitleCase: function(str) {
            return str.replace(/\w\S*/g, function(txt){return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();});
        },

        beginsRegex: function(query) {
            return new RegExp('^' + query.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), 'i');
        },

        containsRegex: function(query) {
            return new RegExp(query.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), 'i');
        },

        isMobile: function(type) {
            var mobiles = {
                Android: function() {
                    return navigator.userAgent.match(/Android/i);
                },
                BlackBerry: function() {
                    return navigator.userAgent.match(/BlackBerry/i);
                },
                iOS: function() {
                    return navigator.userAgent.match(/iPhone|iPad|iPod/i);
                },
                Opera: function() {
                    return navigator.userAgent.match(/Opera Mini/i);
                },
                Windows: function() {
                    return navigator.userAgent.match(/IEMobile/i);
                },
                any: function() {
                    return (mobiles.Android() || mobiles.BlackBerry() || mobiles.iOS() || mobiles.Opera() || mobiles.Windows());
                }
            };

            return mobiles[type || "any"]();
        }
    };
}, "module/utils");// Popup Mixin shared across modal and contentPopup

define(function(require) {
    var mediator = require("module/mediator");

    return {
        initPopupMixin: function() {
            mediator.on("modal:close", this.close, this);
            mediator.on("modal:update:title", this.updateTitle, this);
            mediator.on("modal:showLoading", this.showLoading, this);
            mediator.on("modal:hideLoading", this.hideLoading, this);
            mediator.on("modal:showContext", this.showContext, this);
            mediator.on("modal:hideContext", this.hideContext, this);
            mediator.on("modal:update:classes", this.updateClasses, this);
        },

        showContext: function(context) {
            if (this.$context) {
                this.$context.removeClass("hidden").css({
                    opacity: 1
                }).show();
                this.$context.find(".modal-context-message").html(context);
            }
        },

        hideContext: function(options) {
            options || (options = {});

            if (options.close) {
                this.close(options);
            } else if (options.animate) {
                this.$context.fadeOut(function() {
                    $(this).addClass("hidden");
                });
            } else {
                this.$context.addClass("hidden");
            }
        },

        showLoading: function(options) {
            if (this.$loader) {
                this.$loader.removeClass("hidden");
                this.showLoader(_.extend({
                    $target: this.$loader,
                    loaderClass: "center"
                }, options));
            }
        },

        hideLoading: function() {
            if (this.$loader) {
                this.showChrome();
                this.$loader.addClass("hidden");
                this.hideLoader();
            }
        },

        updateTitle: function(title) {
            if (this.$el) {
                this.$el.find(".modal-title").html(title);
            }
        },

        showChrome: function() {
            if (this.$el) {
                this.$el.find(".modal-header").removeClass("hidden");
                if (this.options.animate) {
                    this.$el.find(".modal-view").addClass("fadeIn");
                }
            }
        },

        updateClasses: function(classes) {
            this.$el.find(".modal-view").removeClass().addClass("modal-view " + classes);
        }
    };
}, "module/mixins/popup");define(function(require) {
    var sizes = {
        small: {
            lines: 11, // The number of lines to draw
            length: 4, // The length of each line
            width: 3, // The line thickness
            radius: 4 // The radius of the inner circle
        }
    };

    return {
        loaderTemplate: Handlebars.templates.loader,
        showLoader: function(options) {
            var $target,
                loader;

            options || (options = {});
            _.extend(options, {
                color: "#6D6E71",
                zIndex: 2
            });

            if (options.size) {
                _.extend(options, sizes[options.size]);
            }

            if (options.target) {
                $target = $(options.target);
            } else {
                $target = options.$target || this.$el;
            }

            this.spinner && this.hideLoader();
            loader = this.loaderTemplate({loaderClass: options.loaderClass || "bottom"});
            if (options.after) {
                $target.after(loader);
                this.spinner = new Spinner(options).spin($target.parent().find(".loader")[0]);
                this.spinner.after = true;
            } else {
                $target.append(loader);
                this.spinner = new Spinner(options).spin($target.find(".loader")[0]);
            }
        },

        hideLoader: function() {
            var $spinnerParent;

            if (this.spinner) {
                $spinnerParent = $(this.spinner.el).parent();
                this.spinner.stop();
                $spinnerParent.remove();
                this.spinner = null;
            }
        }
    };
}, "module/mixins/loader");define(function(require) {
    var Backbone = require("Backbone");

    return Backbone.View.extend({
        template: Handlebars.templates.progressBar,

        initialize: function() {
            var self = this,
                i;

            this.stops = [];
            this.state = {
                current: this.options.current || (this.options.current = 0),
                total: this.options.total || (this.options.total = 1)
            };
            this.state.percent = 100 - (this.state.current / this.state.total) * 100;

            for (i = 1; i <= this.state.total; i++) {
                this.stops.push({
                    count: i,
                    active: i === this.state.current,
                    passed: !!(i < this.state.current),
                    percent: Math.floor((i / this.state.total) * 100)
                });
            }

            this.render();
        },

        render: function() {
            this.$el.html(this.template({
                message: this.options.message,
                state: this.state,
                stops: this.stops
            }));

            return this;
        }
    });
}, "module/progress_bar");(function() {
    var delegateCollectionFetch = Backbone.Collection.prototype.fetch,
        delegateModelFetch = Backbone.Model.prototype.fetch,
        storedOptions,
        boundUpdateCache;

     function fetchCached(options) {
        var delegateFetch,
            savedObj,
            cache,
            key,
            TTL,
            savedTTL,
            now,
            old;


        if (options.cache) {
            storedOptions = options ? _.clone(options) : {};
            options.success || (options.success = function(){});
            cache = options.cache.cache || "session";
            cache = window[cache + "Storage"];
            key = this.getCacheKey();
            TTL = options.cache.TTL;

            removeBindings.call(this);
            boundUpdateCache = _.bind(updateCache, null, cache, key, TTL)
            this.on("add remove updateCache", boundUpdateCache);
            this.on("clean", removeBindings, this);

            if (cache && cache[key]) {
                savedObj = JSON.parse(cache[key]);

                if (savedObj.TTL) {
                    now = new Date();
                    savedTTL = new Date(savedObj.TTL);

                    if (now <= savedTTL) {
                        return cachedSuccess(this, savedObj.data, options);
                    } else {
                        cache.removeItem(key);
                    }
                } else {
                    return cachedSuccess(this, savedObj.data, options);
                }
            }
            options.success = wrapSuccess.call(this, options.success, cache, key, TTL);
        }

        delegateFetch = this.models ? delegateCollectionFetch : delegateModelFetch;
        return delegateFetch.call(this, options);
    }

    function removeBindings() {
        this.off("clean", removeBindings);
        boundUpdateCache && this.off(null, boundUpdateCache);
    }

    function updateCache(cache, key, TTL, model, obj) {
        var current = new Date(),
            data = obj.toData(storedOptions.cache.serializeOptions);

        if (!data){
            return;
        }

        TTL || (TTL = 0);
        TTL = parseInt(current.getTime(), 10) + (TTL * 1000);

        cache[key] = JSON.stringify({
            TTL: TTL,
            data: data
        });
    }

    function wrapSuccess(delegateSuccess, cache, key, TTL) {
        return function(obj, data) {
            updateCache(cache, key, TTL, null, obj);

            if (delegateSuccess) {
                delegateSuccess.apply(this, arguments);
            }
        }.bind(this);
    }

    function cachedSuccess(obj, data, options) {
        if (obj.reset) {
            obj.reset(obj.parse(data), _.extend({parse: true}, options));
        } else {
            obj.set(obj.parse(data), _.extend({silent: true}, options));
        }
        // Let current call stack clear before success is called.
        _.defer(options.success.bind(obj), obj);
    }

    Backbone.Collection.prototype.fetch = fetchCached;
    Backbone.Model.prototype.fetch = fetchCached;
}( ));define(function() {
    "use strict";

    return Backbone.Model.extend({
        initialize: function(attrs, options) {
            options || (options = {});

            if (options.url) {
                this.uri = {
                    url: options.url
                };
            } else if (options.uri) {
                this.uri = options.uri;
            }

            return this;
        },

        url: function() {
            var url = "";

            if (this.uri) {
                url = this.uri.url;
            } else if (this.collection) {
                url = _.result(this.collection, "url");
            }

            return url;
        },

        editUrl: function() {
            // a model may or may not have a url
            try {
                return this.url() + "/edit";
            } catch(e) {
                return "";
            }
        },

        parse: function(raw) {
            var actions,
                interactions;

            raw || (raw = {});

            // BLASPHEMOUS!!!
            if (raw.data && raw.data.data) {
                raw = raw.data;
            }

            this.uri = raw.uri || this.uri;
            this.view = raw.view || this.view || {};
            this.interactions = {};
            this.actions = {};

            interactions = this.view.interaction;
            if (interactions) {
                _.each(interactions, _.bind(this._buildNestedCollection, this, this.interactions));
            }
            actions = this.view.action;
            if (actions) {
                _.each(actions, _.bind(this._buildNestedCollection, this, this.actions));
            }

            return raw.data;
        },

        _buildNestedCollection: function(obj, value, key) {
            var BaseCollection = require("module/collections/base");

            obj[key] = new BaseCollection(value.data.items, {
                uri: value.uri,
                parse: true
            });
        },

        // Returns a "unique" key identifier for the collection
        getCacheKey: function() {
            return this.url();
        },

        toData: function() {
            var interactionData,
                data = {
                uri: _.clone(this.uri),
                view: _.clone(this.view),
                data: _.clone(this.attributes)
            };

            _.each(this.interactions, function(interaction, name) {
                interactionData = interaction.toData();
                if (interactionData) {
                    data.view.interaction[name] = interactionData.data;
                    data.view.interaction[name].data.count = data.view.interaction[name].data.items.length;
                }
            });

            return data;
        },

        toHandlebars: function() {
            var json = _.clone(this.view || {});
            json.cid = this.cid;
            json.editUrl = this.editUrl();

            return json;
        },

        updateCache: function() {
            // Notify fetchCached that we should update the cache
            this.collection && this.collection.updateCache();
            this.trigger("updateCache", this, this.collection);
        },

        save: function(attrs, options) {
            attrs || (attrs = {});
            options || (options = {});

            if (this.uri) {
                options.data || (options.data = {});
                _.extend(options.data, {
                    _token: this.uri.token
                });
            }

            return Backbone.Model.prototype.save.call(this, attrs, options);
        },

        destroy: function(options) {
            var paramData;

            paramData = $.param({
                _token: this.uri.token
            });
            options = options ? _.clone(options) : {};
            options = _.extend({
                data: paramData
            }, options);

            return Backbone.Model.prototype.destroy.call(this, options);
        },

        // Creates a new collection if not already defined and returns
        // a fetch promise, otherwise it returns a promise which will resolve
        // immediately. Takes a key name to store the collection on the object,
        // a Collection constructor, and collection options.
        fetchStatic: function(key, Collection, options) {
            var collection = this[key],
                deferred,
                promise;

            if (!collection) {
                collection = new Collection([], options);
                this[key] = collection;
                promise = collection.fetch(options);
            } else {
                deferred = $.Deferred();
                promise = deferred.promise();
                deferred.resolve(collection);
                if (options.success) {
                    _.defer(options.success, collection);
                }
            }

            // Always return a promise
            return promise;
        }
    });
}, "module/models/base");define(function() {
    "use strict";

    var Backbone = require("Backbone"),
        BaseModel = require("module/models/base");

    return BaseModel.extend({

    });
}, "module/models/list");define(function() {
    "use strict";

    var BaseModel = require("module/models/base");

    return Backbone.Collection.extend({
        model: BaseModel,

        initialize: function(items, options) {
            options || (options = {});
            _.extend(options, {
                parse: true
            });
            if (options.uri) {
                this.uri = options.uri;
            } else if (options.url) {
                this.uri = {
                    url: options.url
                };
            } else {
                this.uri = {};
            }

            options.next && (this.next = options.next);
            options.view && (this.view = options.view);
            this.next && (this.pageStateId = options.next._pageStateId);
        },


        url: function() {
            return this.uri.url;
        },

        get: function(id) {
            var item = Backbone.Collection.prototype.get.call(this, id);

            // check if item is referenced by view id
            if (!item) {
                item = this.find(function(model) {
                    return model.view && model.view.data.id == id;
                });
            }

            return item;
        },

        parse: function(response) {
            var data;

            // clear the previous next
            delete this.next;

            if (_.isArray(response)) {
                data = response;
            } else {
                this.uri = response.data.uri;
                this.view = response.data.view;
                this.view && (this.next = this.view.next);
                this.next && (this.pageStateId = this.next._pageStateId);
                data = response.data.data.items;
            }

            return data;
        },

        // Returns a "unique" key identifier for the collection
        getCacheKey: function() {
            var extra = "";

            if (this.next && this.next.filter) {
                extra = ":" + this.next.filter;
            } else if (this.filterParam) {
                extra = ":" + this.filterParam;
            }

            return this.url() + extra;
        },

        // Opposite of parse
        toData: function(options) {
            var items,
                data;

            options || (options = {});

            items = this.map(function(model) {
                return model.toData();
            });

            // Allow option of not serializing empty object
            if (options.ensureItems) {
                if (!items.length) {
                    return;
                }
            }

            data = {
                uri: this.uri,
                data: {
                    items: items
                }
            };

            if (this.view) {
                data.view = {
                    next: this.next
                };
            }

            return {
                data: data
            };
        },

        toHandlebars: function() {
            return this.map(function(model) {
                return model.toHandlebars();
            });
        },

        updateCache: function() {
            this.trigger("updateCache", null, this);
        },

        fetch: function(options) {
            var jqXHR;

            options = options ? _.clone(options) : {};
            options.data || (options.data = {});
            options.parse = true;

            // Merge the current next over the data
            this.next && (options.data = _.extend(options.data, this.next));

            // Allow overriding of pageStateId
            this.pageStateId && (options.data._pageStateId = this.pageStateId);

            // Update the collections filter if specified in options
            options.filter && (this.filterParam = options.filter);

            // Set query filter based on collections filter
            this.filterParam && (options.data._filter = this.filterParam);

            // Update the collections search query if specified in options
            options.query && (this.query = options.query);

            // Set the search query based on collections query
            this.query && (options.data._query = this.query);

            options.query && (options.data._query = options.query);
            options.count && (options.data._count = options.count);

            jqXHR = Backbone.Collection.prototype.fetch.call(this, options);
            this.trigger("fetch");

            return jqXHR;
        },

        clean: function() {
            delete this.filterParam;
            delete this.query;
            delete this.next;

            this.trigger("clean");
        },

        create: function(data, options) {
            data = _.extend({
                _token: this.uri.token
            }, data);

            // returns model
            return Backbone.Collection.prototype.create.call(this, data, options);
        }
    });
}, "module/collections/base");define(function() {
    "use strict";

    var BaseCollection = require("module/collections/base"),
        List = require("module/models/list");

    return BaseCollection.extend({
        model: List,

        comparator: function(list) {
            if (list.get("timestampModified")) {
                return -list.get("timestampModified");
            } else {
                return -list.get("timestampCreated");
            }
        }
    });
}, "module/collections/lists");define(function(require) {
    var BaseModel = require("module/models/base");

    return BaseModel.extend({});
}, "module/models/user");define(function() {
    "use strict";

    var Backbone = require("Backbone"),
        loaderMixin = require("module/mixins/loader"),
        TrackingModule = require("module/tracking"),
        mediator = require("module/mediator"),
        utils = require("module/utils");

    return Backbone.View.extend({
        mediator: mediator,

        initialize: function(options) {
            options || (options = {});
            options.template && !this.template && (this.template = options.template);
            _.extend(this, loaderMixin);
            new TrackingModule(this);
        },

        stopProp: function(e) {
            if (e && e.stopPropagation) {
                e.stopPropagation();
                e.preventDefault();
            }
        },

        stopPropagation: function(e) {
            e && e.stopPropagation && e.stopPropagation();
        },

        resetView: function() {
            this.hideLoader();
            this.$el.html("").css({
                height: "auto"
            });
            this.dropdown && this.dropdown.remove();
            this.undelegateEvents();
            this.infiniteScroll && this.infiniteScroll.enableFetch();
        },

        onError: function(obj, response) {
            var message = "";

            if (response.statusText === "abort" || response.status === 0) {
                return;
            }

            try {
                response = JSON.parse(response.responseText);
                message = response.meta.message;
            } catch (e) {
                message = "Don't worry. The engineers will pay dearly for this outage.";
            }

            this.hideLoader && this.hideLoader();
            this.$el.find(".no-results").remove();
            this.$el.after(Handlebars.templates.onError({
                message: message
            }));
        },

        initScroller: function(){
            var $scrollerWrap = this.$el.find('.antiscroll-wrap'),
                $scrollerInner = this.$el.find('.antiscroll-inner');

            if (!$scrollerWrap.length && this.$el.hasClass("antiscroll-wrap")) {
                $scrollerWrap = this.$el;
            }

            if ($scrollerWrap) {
                $scrollerWrap.width($scrollerWrap.width());
                $scrollerInner.width($scrollerWrap.width());
                $scrollerWrap.find(".antiscroll-inner").css({
                    "height": $scrollerWrap.height() + "px",
                    "overflow-y": "scroll"
                });
            }
            if (!this.options.osScroller && !utils.isMobile()) {
                this.scroller && this.scroller.destroy();
                this.scroller = $scrollerWrap.antiscroll({
                    x: false
                }).data('antiscroll');
            }
        },

        getClosestById: function(e) {
            return this.collection.get($(e.currentTarget).closest("[data-id]").attr("data-id"));
        },

        getItemById: function(e, closest) {
            var item;

            if (closest) {
                item = this.collection.get($(e.currentTarget).closest(closest).attr("data-id"));
            } else {
                item = this.collection.get($(e.currentTarget).attr("data-id"));
            }

            return item;
        },

        getItemByCid: function(e) {
            return this.collection.getByCid($(e.currentTarget).attr("data-cid"));
        }
    });
}, "module/views/base");define(function(require) {
    "use strict";

    var BaseView = require("module/views/base"),
        mediator = require("module/mediator");

    return BaseView.extend({
        successMessageDelay: 2000,

        events: {
            "click .close": "close"
        },

        initialize: function(options) {
            _.bindAll(this, "showConfirm", "confirmCancel", "onConfirm", "close", "onSuccess", "onError");
            BaseView.prototype.initialize.call(this, options);
        },

        showConfirm: function(options) {
            mediator.trigger("modal:showContext", Handlebars.templates.confirm(options));
            options.onConfirm && (this.onConfirm = options.onConfirm);

            $("#confirm").off("click", this.onConfirm);
            $("#confirm").on("click", this.onConfirm.bind(this));
            $("#confirm-cancel").off("click", this.confirmCancel);
            $("#confirm-cancel").on("click", this.confirmCancel.bind(this));
        },

        confirmCancel: function(e) {
            this.stopProp(e);
            mediator.trigger("modal:hideContext");
        },

        onConfirm: function(e) {
            this.stopProp(e);
        },

        showLoading: function() {
            mediator.trigger("modal:showLoading");
        },

        hideLoading: function() {
            mediator.trigger("modal:hideLoading");
        },

        close: function(e) {
            this.stopProp(e);
            this.undelegateEvents();
            $("#confirm").off("click", this.onConfirm);
            $("#confirm-cancel").off("click", this.confirmCancel);

            this.trigger("close", e);
            mediator.trigger("modal:close", e);
        },

        onSuccess: function(model, response) {
            mediator.trigger("modal:hideLoading");
            mediator.trigger("modal:showContext", response.meta.message);
            setTimeout(function() {
                mediator.trigger("modal:hideContext", {
                    close: true,
                    animate: true
                });
            }, this.successMessageDelay);
        },

        onError: function(model, response) {
            response = JSON.parse(response.responseText);

            mediator.trigger("modal:hideLoading");
            mediator.trigger("modal:showContext", response.meta.message);
            setTimeout(function() {
                mediator.trigger("modal:hideContext", {
                    animate: true
                });
            }, this.successMessageDelay);
        }
    });
}, "module/views/overlay_view");define(function(require) {
    var BaseView = require("module/views/base"),
        popupMixin = require("module/mixins/popup"),
        mediator = require("module/mediator");

    return BaseView.extend({
        el: "body",
        template: Handlebars.templates.modal,

        events: {
            "click .modal-close": "close",
            "click .modal-wrap": "stopPropagation",
            "keyup": "keyPress"
        },

        initialize: function(options) {
            BaseView.prototype.initialize.call(this, options);
            this.templateOptions = options.templateOptions || {};
            options.animate && (this.templateOptions.animate = options.animate);
            this.ModalView = options.view;
            this.viewOptions = options.viewOptions || {};
            this.afterRender = options.afterRender || function() {};
            this.skipLoader = options.skipLoader || false;

            if (!this.options.disableClickToClose) {
                this.events = _.extend({}, this.events, {
                    "click": "close"
                });
            }

            _.extend(this, popupMixin);
            this.initPopupMixin();

            this.viewOptions = _.extend({
                el: ".modal-body"
            }, this.viewOptions);

            BaseView.prototype.initialize.call(this, options);

            this.render();
        },

        render: function() {
            this.$el.append(this.template(_.extend({
                modalClass: this.options.modalClass,
                title: this.options.title,
                subTitle: this.options.subTitle,
                noCloseButton: this.options.noCloseButton || this.options.unclosable
            }, this.templateOptions)));
            this.$el.addClass("modal-mode");
            this.$loader = this.$el.find(".loading");
            this.$context = this.$el.find(".modal-context");

            if (!this.skipLoader && !this.options.contentTemplate) {
                this.showLoading();
            } else {
                _.defer(this.showChrome.bind(this));
            }

            if (this.ModalView) {
                this.modalView = new this.ModalView(this.viewOptions);
                this.modalView.on("close", this.close, this);
            } else if (this.options.contentTemplate) {
                this.$el.find(".modal-body").html(
                    this.options.contentTemplate(this.options.contentTemplateData)
                );
            }
            this.afterRender(this);
            this.trigger("afterRender");
        },

        keyPress: function(e) {
            if (e.keyCode === 27) {
                this.close();
            }
        },

        close: function(options) {
            options || (options = {});

            if (this.options.unclosable) {
                return;
            }

            if (options.animate) {
                this.$el.find(".modal-view").fadeOut(this._close.bind(this));
            } else {
                this._close();
            }
        },

        _close: function() {
            this.undelegateEvents();
            this.$el.removeClass("modal-mode");
            this.$el.find(".modal-view").remove();
            this.trigger("close");
            this.modalView && this.modalView.trigger("modal:close");
        }
    });
}, "module/modal");define(function() {
    var BaseView = require("module/views/base"),
        mediator = require("module/mediator"),
        utils = require("module/utils"),
        UP = 38,
        DOWN = 40,
        ENTER = 13,
        SHIFT = 16,
        ESC = 27;

    return BaseView.extend({
        el: "body",
        template: Handlebars.templates.dropdown,
        dropdownTemplate: Handlebars.templates.dropdownList,
        currentItem: 0,
        focusItem: -1,
        cachedResults: {},
        requestFinished: true,

        initialize: function(options) {
            _.bindAll(this, "hideDropdown", "focusOption", "unFocusOption",
                    "selectOption", "filterItems", "createNew", "keyPress");
            this.options.position || (this.options.position = {});
            this.options.offset || (this.options.offset = {top: 0, left: 0});
            this.ajaxKey = options.ajaxKey || "query";
            this.itemKey = options.itemKey || "name";
            this.absolute = !this.options.position.static;
            this.dropdownItemsSelector = ".dropdown-items-wrap[data-cid='" + this.cid + "']";

            mediator.on("dropdown:clean", this.clean, this);
            mediator.on("dropdown:inputUpdate", this.inputUpdate, this);

            this.renderDropdown();
            if (!options.noFocus) {
                this.$el.find(".dropdown-search").focus();
            }
        },

        attachDropdownEvents: function(dropdownItemsSelector) {
            $("body").off("mouseover", ".dropdown-item");
            $("body").on("mouseover", this.dropdownItemsSelector + " .dropdown-item", this.focusOption);
            $("body").off("mouseout", ".dropdown-item");
            $("body").on("mouseout", this.dropdownItemsSelector + " .dropdown-item", this.unFocusOption);
            $("body").off("click", ".dropdown-item");
            $("body").on("click", this.dropdownItemsSelector + " .dropdown-item", this.selectOption);
            this.$dropdown.find(".dropdown-search").on("keyup", this.keyPress);
            this.$dropdown.find(".dropdown-search").on("keyup keydown keypress", this.filterItems);

            $(window).on("click", this.hideDropdown.bind(this));
        },

        stopPropagation: function(e) {
            e.stopPropagation();
            e.preventDefault();
        },

        clean: function() {
            this.inputUpdate("");
            this.abortServerFilter();
            this.resetFocus();
        },

        remove: function() {
            this.$dropdownItems.remove();
            Backbone.View.prototype.remove.call(this);
        },

        inputUpdate: function(val) {
            this.$el.find(".dropdown-search").val(val);
        },

        toDropdownFormat: function(collection) {
            var self = this;

            return collection.map(function(item) {
                return {
                    cid: item.cid,
                    value: item.get(self.itemKey),
                    valueToBold: ""
                };
            });
        },

        toMatchFormat: function(collection, query, filter) {
            var self = this,
                match = false,
                items = [],
                queryLength,
                matchIndex,
                itemJSON,
                value,
                json,
                regex;

            collection.each(function(item) {
                value = item.get(self.itemKey);
                regex = utils.beginsRegex(query);
                itemJSON = item.toHandlebars();
                itemJSON.value = value;
                if (regex.test(value) && query) {
                    queryLength = query.length;
                    matchIndex = value.indexOf(query);
                    if (value === query) {
                        match = true;
                        itemJSON.valueToBold = value;
                        itemJSON.value = "";
                    } else if (queryLength > 0) {
                        itemJSON.valueToBold = value.substring(matchIndex, matchIndex + queryLength + 1);
                        itemJSON.valueBefore = value.substring(0, matchIndex);
                        itemJSON.value = value.substring(matchIndex + queryLength + 1);
                    }
                    filter && items.push(itemJSON);
                } else if (!query || !filter){
                    items.push(itemJSON);
                }
            });

            return {
                items: items,
                match: match
            };
        },

        renderDropdown: function() {
            var data = this.toDropdownFormat(this.collection);

            this.rendered = true;
            this.$el.html(this.template({
                items: data,
                viewCid: this.cid,
                allowCreate: this.options.allowCreate,
                placeholder: this.options.placeholder,
                absolute: this.absolute
            }));
            this.$dropdown = this.$el.find(".dropdown[data-cid='" + this.cid + "']");
            this.$dropdownItems = $(this.dropdownItemsSelector);

            if (this.absolute) {
                $('body').append(this.dropdownTemplate({
                    items: data,
                    viewCid: this.cid,
                    allowCreate: this.options.allowCreate
                }));
                this.$dropdownItems = $(this.dropdownItemsSelector);
            } else {
                this.$dropdownItems.show();
            }
            this.initScroller();
            this.$el.find('.dropdown-search').placeholder();

            this.attachDropdownEvents();
        },

        positionDropdown: function() {
            var targetPos = this.$dropdown.offset(),
                targetWidth = this.$dropdown.outerWidth(),
                css;

            this.options.offset.top || (this.options.offset.top = 0);
            this.options.offset.left || (this.options.offset.left = 0);

            css = {
                position: "absolute",
                height: this.options.height || 300,
                width: this.options.width || targetWidth,
                top: targetPos.top + this.$dropdown.outerHeight() + this.options.offset.top,
                left: targetPos.left + this.options.offset.left,
                'z-index': 5
            };

            this.$dropdownItems.css(css);
        },

        updateDropdown: function(items, query, match) {
            if (items.length) {
                items[0].preSelected = true;
            }

            $(this.dropdownItemsSelector).replaceWith(Handlebars.templates.dropdownList({
                viewCid: this.cid,
                items: items,
                query: query,
                match: match,
                allowCreate: this.options.allowCreate,
                absolute: this.absolute
            }));
            this.$dropdownItems = $(this.dropdownItemsSelector);
            this.absolute && this.positionDropdown();
            this.resetFocus();

            if (!this.options.allowCreate && !items.length){
                this.hideDropdown();
            } else {
                this.showDropdown();
                this.initScroller();
            }
        },

        hideDropdown: function() {
            if (!this.options.disableHide) {
                this.$dropdownItems.hide();
            }
        },

        showDropdown: function() {
            this.$dropdownItems.show();
        },

        filterItems: function(e) {
            var query = this.$dropdown.find(".dropdown-search").val();

            this.abortServerFilter();
            if (e && !e.shiftKey && (e.which === UP || e.which === DOWN || e.which === ESC)) {
                e.preventDefault();
                return;
            } else if (e.which === ENTER){
                e.preventDefault();
                this.hideDropdown();
                if (this.requestFinished) {
                    return;
                }
            }

            if (e.which !== SHIFT) {
                if (this.options.ajax) {
                    this.filterServer(query);
                } else {
                    this.filterLocal(query);
                }
            }
        },

        filterServer: _.debounce(function(query) {
            var self = this,
                results = this.cachedResults[query],
                data;

            if (!query || query.length <= 2) {
                this.hideDropdown();
                return;
            }

            if (results) {
                this.collection.reset(this.collection.parse(results), {
                    silent: true,
                    parse: true
                });
                data = self.toMatchFormat(self.collection, query);
                self.updateDropdown(data.items, query, false);
            } else {
                data = {};

                this.requestFinished = false;
                this.showSpinner();
                this.activeAjaxRequest = this.collection.fetch({
                    parse: true,
                    data: data,
                    query: query,
                    success: function(collection, data) {
                        self.requestFinished = true;
                        self.cachedResults[query] = data;

                        self.hideSpinner();
                        data = self.toDropdownFormat(self.collection);
                        self.updateDropdown(data, query, false);
                    }
                });
            }
        }, 100),

        abortServerFilter: function() {
            if (this.activeAjaxRequest) {
                this.hideSpinner();
                this.activeAjaxRequest.abort();
                delete this.activeAjaxRequest;
            }
        },

        filterLocal: function(query) {
            var data = this.toMatchFormat(this.collection, query, true);
            this.updateDropdown(data.items, query, data.match);
        },

        keyPress: function(e) {
            var target,
                $input = this.$dropdown.find(".dropdown-search"),
                itemCount = this.$dropdownItems.find(".dropdown-item").length - 1,
                focusItem;

            // Will refator this
            if (e.which === UP) {
                focusItem = this.focusItem - 1;
                focusItem = focusItem < 0 ? itemCount : focusItem;
                target = this.$dropdownItems.find(".dropdown-item:eq(" + focusItem + ")").get(0);
                e.currentTarget = target;
                this.scrollToTarget(e);
                this.focusOption(e);
            } else if (e.which === DOWN) {
                focusItem = this.focusItem + 1;
                focusItem = focusItem > itemCount ? 0 : focusItem;
                target = this.$dropdownItems.find(".dropdown-item:eq(" + focusItem + ")").get(0);
                e.currentTarget = target;
                this.scrollToTarget(e);
                this.focusOption(e);
            } else if (e.which === ENTER) {
                target = this.$dropdownItems.find(".dropdown-item:eq(" + this.focusItem + ")").get(0);
                e.currentTarget = target;
                if (this.requestFinished) {
                    this.selectOption(e);
                }
            } else if (e.which === ESC) {
                if ($input.is(":focus")) {
                    this.hideDropdown();
                }
            }
        },

        scrollToTarget: function(e) {
            var $item = $(e.currentTarget);
                $dropdownContent = this.$dropdownItems.find(".dropdown-items"),
                dropdownScrollTop = $dropdownContent.scrollTop(),
                itemTop = $item.position().top;

            $dropdownContent.scrollTop(dropdownScrollTop + itemTop);
        },

        focusOption: function(e) {
            var $item = $(e.currentTarget);

            this.focusItem = this.$dropdownItems.find(".dropdown-item").index($item);
            this.$dropdownItems.find(".dropdown-item").removeClass("s-active");
            $item.addClass("s-active");
        },

        unFocusOption: function(e) {
            this.resetFocus();
            this.$dropdownItems.find(".dropdown-item").removeClass("s-active");
        },

        resetFocus: function() {
            // Reset the focus to top
            this.focusItem = 0;
        },

        showSpinner: function() {
            if (!this.spinner) {
                this.spinner = new Spinner({
                    lines: 11, // The number of lines to draw
                    length: 3, // The length of each line
                    width: 2, // The line thickness
                    radius: 4, // The radius of the inner circle
                    color: '#888' // #rgb or #rrggbb
                });
            }
            this.spinner.spin(this.$dropdown.find(".spinner").get(0));
            this.$dropdown.addClass("spinning");
        },

        hideSpinner: function() {
            this.spinner.stop();
            this.$dropdown.removeClass("spinning");
        },

        selectOption: function(e) {
            var $item = $(e.currentTarget),
                item = this.collection.getByCid($item.data("cid"));

            this.stopPropagation(e);
            this.hideDropdown();

            if (item) {
                // update text field with selection
                this.$dropdown.find(".dropdown-search").val(item.get(this.itemKey));
                item.set("selected", true);
                this.trigger("item:selected", item);
            } else {
                this.createNew();
            }
        },

        createNew: function() {
            var query = this.$dropdown.find(".dropdown-search").val();

            if (query) {
                this.trigger("createNew", {item: query});
            }
        }
    });
}, "module/dropdown");define(function() {
    "use strict";

    var OverlayView = require("module/views/overlay_view"),
        Lists = require("module/collections/lists"),
        BaseModel = require("module/models/base"),
        Dropdown = require("module/dropdown"),
        mediator = require("module/mediator");

    return OverlayView.extend({
        successMessageDelay: 1500,
        initialize: function(options) {
            var self = this;

            options.dropdownOptions || (this.options.dropdownOptions = {});
            OverlayView.prototype.initialize.call(this, options);

            this.collection = new Lists([], {
                url: options.viewer.view.data.urlLists
            });

            this.collection.fetch({
                cache: {
                    TTL: 60 * 60 * 24
                },
                data: {
                    _view: "selectStumbleList",
                    _count: 100
                },
                success: function(collection) {
                    self.collection = collection;
                    self.renderSelect();
                    mediator.trigger("view:listSelect:ready");
                }
            });
        },

        renderSelect: function() {
            mediator.trigger("modal:hideLoading");

            this.dropdown = new Dropdown({
                el: this.el,
                target: this.$el,
                collection: this.collection,
                height: this.options.dropdownOptions.height || 235,
                width: this.options.dropdownOptions.width || 307,
                immediate: this.options.dropdownOptions.immediate,
                allowCreate: this.options.dropdownOptions.allowCreate,
                disableHide: true,
                position: {
                    static: true
                }
            });

            this.dropdown.on("item:selected", this.addToList.bind(this));
            this.dropdown.on("createNew", this.createList.bind(this));
            this.on("modal:close", this.dropdown.remove, this.dropdown);
        },

        addToList: function(model) {
            var self = this,
                list = this.collection.get(model.id),
                listItem;

            this.showLoading();

            listItem = new BaseModel({
                listId: list.id,
                urlId: this.options.urlId ? this.options.urlId : '',
                url: this.options.url ? this.options.url : ''
            }, {
                uri: list.view.data.items.uri
            });

            listItem.save({}, {
                success: this.onSuccess.bind(this),
                error: this.onError.bind(this)
            });
        },

        createList: function(data) {
            var ListEditView = require("module/views/list_edit_view"),
                list;

            list = new BaseModel({
                name: data.item
            }, {
                uri: this.collection.uri
            });

            mediator.trigger("modal:update:title", "Create List");
            new ListEditView({
                el: this.el,
                model: list,
                collection: this.collection,
                urlId: this.options.urlId ? this.options.urlId : '',
                url: this.options.url ? this.options.url : ''
            });
        }
    });
}, "module/views/lists_select_view");define(function(require) {
    var OverlayView = require("module/views/overlay_view");

    return OverlayView.extend({
        template: Handlebars.templates.listEdit,
        events: {
            "click #list-save": "save",
            "submit .modal-form": "save",
            "click #list-destroy": "requestConfirm",
            "click #list-cancel": "close"
        },

        initialize: function(options) {
            OverlayView.prototype.initialize.call(this, options);

            this.list = options.list;
            this.urlId = options.urlId;
            this.url = options.url;

            this.render();

            this.mediator.trigger("view:listEdit:ready");
        },

        render: function() {
            var data,
                json;

            if (this.model.isNew()) {
                json = {
                    name: this.model.get("name"),
                    description: "",
                    visibility: "",
                    isNew: true
                };
            } else {
                data = this.model.toHandlebars();
                json = {
                    name: data.data.namePretty,
                    description: data.data.description,
                    visibility: data.data.visibility,
                    isNew: false
                };
            }

            this.$el.html(this.template(json));
            this.delegateEvents(this.events);

            if (this.model.isNew()) {
                this.$el.find("#list-edit-description").focus();
            }
            return this;
        },

        requestConfirm: function(e) {
            this.stopProp(e);
            this.showConfirm({
                message: "Are you sure you want to<br/>delete this list?",
                onConfirm: this.destroy
            });
        },

        save: function(e) {
            var name = this.$el.find("#list-edit-name").val(),
                description = this.$el.find("#list-edit-description").val(),
                visibility = this.$el.find('input:radio[name=visibility]:checked').val(),
                extraParams = {},
                data;

            this.stopProp(e);
            this.mediator.trigger("modal:showLoading");

            data = {
                name: name,
                description: description,
                visibility: visibility
            };
            this.urlId && (data.urlId = this.urlId);
            this.url && (data.url = this.url);
            if (this.model.isNew()) {
                extraParams._view = "selectStumbleList";
            } else {
                extraParams._view = this.options.requestView || "";
            }

            // update model view :( :( :(
            if (this.model.view) {
                this.model.view.data.namePretty = name;
                this.model.view.data.description = description;
                this.model.view.data.visibility = visibility;
            }

            this.model.save(data, {
                success: this.listCreated.bind(this),
                error: this.onError.bind(this),
                data: extraParams,
                wait: true
            });
        },

        listCreated: function() {
            if (this.collection && !this.model.collection) {
                this.collection.add(this.model);
            }
            this.onSuccess.apply(this, arguments);
        },

        destroy: function() {
            this.mediator.trigger("modal:hideContext");
            this.mediator.trigger("modal:showLoading");

            this.model.destroy();
            if (this.options.waitOnDestroy) {
                mediator.trigger("modal:showLoading");
            } else {
                this.close();
            }
        }
    });
}, "module/views/list_edit_view");define(function(require) {
    var OverlayView = require("module/views/overlay_view");

    return OverlayView.extend({
        template: Handlebars.templates.signin,

        events: {
            "click #back": "back"
        },

        initialize: function(options) {
            OverlayView.prototype.initialize.call(this, options);

            this.render();
        },

        render: function() {

            this.$el.html(this.template({
                uri: this.options.uri,
                next: this.options.next,
                noBackButton: this.options.noBackButton
            }));

            this.mediator.trigger("modal:update:title", "Please Sign-In");
        },

        back: function(e) {
            this.stopProp(e);
            this.resetView();
            this.trigger("back");
        }
    });
}, "module/views/signin_view");define(function(require) {
    var OverlayView = require("module/views/overlay_view"),
        SignInView = require("module/views/signin_view");

    return OverlayView.extend({
        template: Handlebars.templates.forcedRegIndex,

        events: {
            "click #sign-in": "signIn"
        },

        initialize: function(options) {
            OverlayView.prototype.initialize.call(this, options);

            this.render();
        },

        render: function() {
            this.mediator.trigger("modal:update:classes", "fb-connect-welcome large");
            this.mediator.trigger("modal:update:title", "");
            this.$el.html(this.template({
                urlCurrent: window.location.href
            }));
            this.delegateEvents(this.events);
        },

        signIn: function(e) {
            this.stopProp(e);
            this.undelegateEvents();

            this.signInView = new SignInView({
                el: this.$el,
                uri: this.options.message.uri,
                next: this.options.message.data.next
            });
            this.signInView.on("back", this.render, this);

            this.mediator.trigger("modal:update:classes", "small");
        }
    });
}, "module/views/facebook_signup_view");define(function(require) {
    var Modal = require("module/modal"),
        mediator = require("module/mediator");

    return {
        initialize: function(options) {
            this.adxMessages = options.adxUrls;
            // Setup routes for each adx modal
            mediator.on("route", this.onRoute, this);

            route = window.location.pathname;
            if ('/' == route.charAt(route.length - 1))
                route = route.slice(0, -1);

            this.onRoute(route);
        },

        onRoute: function(route) {
            var adxData = this.adxMessages[route];
            if (adxData) {
                var templateName = adxData.type,
                    viewName = adxData.view || false,
                    template;

                if (viewName) {
                    Modal = require('module/views/modals/' + viewName);

                    var modal = new Modal({
                        modalClass: "adx-modal",
                        skipLoader: true,
                        extra: adxData.extra || {}
                    });
                } else {
                    template = Handlebars.templates[templateName];

                    var modal = new Modal({
                        skipLoader: true,
                        modalClass: "adx-modal",
                        contentTemplate: template
                    });

                    modal.on("close", function(){
                        if (adxData.uri)
                        {
                            $.post(adxData.uri.url, {
                                _token: adxData.uri.token
                            }, '', 'json');
                        }
                    });
                }
            }
        }
    };
}, "module/routers/adx_machine");define(function(require) {
    var BaseView = require("module/modal");

    return BaseView.extend({
        events: {
            "click .primary": "doAction"
        },

        initialize: function(options) {
            var extra = options.extra || {},
                templateName = extra.template || "";
            this.uri = extra.uri || {};
            this.redirectUrl = extra.redirectUrl || "";
            options.contentTemplate = Handlebars.templates[templateName];
            BaseView.prototype.initialize.call(this, options);
        },

        doAction: function() {
            var redirectUrl = this.redirectUrl;
            if (this.uri)
            {
                $.post(this.uri.url, {
                    _token: this.uri.token
                }, function(data) {
                    window.location = redirectUrl;
                }, 'json');
            }
        }
    });
}, "module/views/modals/mobile_app_redir");define(function(require) {
    var BaseView = require("module/views/base");

    return BaseView.extend({
        template: Handlebars.templates.toolbarTutorialv2,

        events: {
            "click": "close"
        },

        initialize: function() {
            return this.render();
        },

        render: function() {
            var self = this;

            this.$el.html(this.template({
                currentStumble: this.options.currentStumble
            }));

            setTimeout(function() {
                self.$el.removeClass("fadeOut");
            }, 1000);

            return this;
        },

        close: function() {
            var self = this;

            this.$el.addClass("fadeOut");
            setTimeout(function() {
                self.$el.remove();
            }, 500);
        }
    });
}, "module/views/toolbar_tutorial_view");define(function(require) {
    var BaseView = require("module/views/base");

    return BaseView.extend({
        template: Handlebars.templates.reveal,
        events: {
            "click": "close"
        },

        initialize: function(options) {
            BaseView.prototype.initialize.call(this, options);
            this.options.data.id = this.options.data.id.split(",")[0];

            this.render();
        },

        render: function() {
            var self = this;

            this.$el.append(this.template({
                id: this.options.data.id,
                template: this.options.data.template
            }));
            setTimeout(function() {
                $("#tb-toolbar").addClass(self.options.data.id + "-reveal");
                self.$el.find(".reveal-wrap").removeClass("fadeOut");
            }, 500);
        },

        close: function() {
            var $target = this.$el.find(".reveal-wrap");

            $target.addClass("fadeOut");
            $("#tb-toolbar").removeClass(this.options.data.id + "-reveal");
            setTimeout(function() {
                $target.remove();
            }, 500);
        }
    });
}, "module/views/reveal_tooltip_view");define(function(require) {
    return {
        "firstRun": {
            1: {
                id: "",
                fn: "initTutorial"
            },
            4: {
                id: "tb-lists",
                template: "toolbarTutorialList"
            },
            8:  {
                id: "tb-comment",
                template: "toolbarTutorialComment"
            },
            12:  {
                id: "tb-share, #tb-share-facebook",
                template: "toolbarTutorialShare"
            },
            16: {
                id: "tb-interests",
                template: "toolbarTutorialInterests"
            }
        }
    };
}, "tutorialSequences");